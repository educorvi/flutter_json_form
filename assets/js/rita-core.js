!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.rita = t() : e.rita = t() }(globalThis, () => (() => {
    "use strict"; var e = {
        58: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/meta/core","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/core":true},"$recursiveAnchor":true,"title":"Core vocabulary meta-schema","type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference","$comment":"Non-empty fragments not allowed.","pattern":"^[^#]*#?$"},"$schema":{"type":"string","format":"uri"},"$anchor":{"type":"string","pattern":"^[A-Za-z][-A-Za-z0-9.:_]*$"},"$ref":{"type":"string","format":"uri-reference"},"$recursiveRef":{"type":"string","format":"uri-reference"},"$recursiveAnchor":{"type":"boolean","default":false},"$vocabulary":{"type":"object","propertyNames":{"type":"string","format":"uri"},"additionalProperties":{"type":"boolean"}},"$comment":{"type":"string"},"$defs":{"type":"object","additionalProperties":{"$recursiveRef":"#"},"default":{}}}}') }, 117: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(2586), n = r(5765), a = r(4227), o = r(8660), i = { keyword: "properties", type: "object", schemaType: "object", code(e) { const { gen: t, schema: r, parentSchema: i, data: c, it: u } = e; "all" === u.opts.removeAdditional && void 0 === i.additionalProperties && o.default.code(new s.KeywordCxt(u, o.default, "additionalProperties")); const l = (0, n.allSchemaProperties)(r); for (const e of l) u.definedProperties.add(e); u.opts.unevaluated && l.length && !0 !== u.props && (u.props = a.mergeEvaluated.props(t, (0, a.toHash)(l), u.props)); const d = l.filter(e => !(0, a.alwaysValidSchema)(u, r[e])); if (0 === d.length) return; const h = t.name("valid"); for (const r of d) m(r) ? f(r) : (t.if((0, n.propertyInData)(t, c, r, u.opts.ownProperties)), f(r), u.allErrors || t.else().var(h, !0), t.endIf()), e.it.definedProperties.add(r), e.ok(h); function m(e) { return u.opts.useDefaults && !u.compositeRule && void 0 !== r[e].default } function f(t) { e.subschema({ keyword: "properties", schemaProp: t, dataProp: t }, h) } } }; t.default = i }, 208: (e, t, r) => {
            Object.defineProperty(t, "__esModule", { value: !0 }), t.reportTypeError = t.checkDataTypes = t.checkDataType = t.coerceAndCheckDataType = t.getJSONTypes = t.getSchemaTypes = t.DataType = void 0; const s = r(396), n = r(7887), a = r(8708), o = r(9029), i = r(4227); var c; function u(e) { const t = Array.isArray(e) ? e : e ? [e] : []; if (t.every(s.isJSONType)) return t; throw new Error("type must be JSONType or JSONType[]: " + t.join(",")) } !function (e) { e[e.Correct = 0] = "Correct", e[e.Wrong = 1] = "Wrong" }(c || (t.DataType = c = {})), t.getSchemaTypes = function (e) { const t = u(e.type); if (t.includes("null")) { if (!1 === e.nullable) throw new Error("type: null contradicts nullable: false") } else { if (!t.length && void 0 !== e.nullable) throw new Error('"nullable" cannot be used without "type"'); !0 === e.nullable && t.push("null") } return t }, t.getJSONTypes = u, t.coerceAndCheckDataType = function (e, t) {
                const { gen: r, data: s, opts: a } = e, i = function (e, t) { return t ? e.filter(e => l.has(e) || "array" === t && "array" === e) : [] }(t, a.coerceTypes), u = t.length > 0 && !(0 === i.length && 1 === t.length && (0, n.schemaHasRulesForType)(e, t[0])); if (u) {
                    const n = h(t, s, a.strictNumbers, c.Wrong); r.if(n, () => {
                        i.length ? function (e, t, r) {
                            const { gen: s, data: n, opts: a } = e, i = s.let("dataType", o._`typeof ${n}`), c = s.let("coerced", o._`undefined`); "array" === a.coerceTypes && s.if(o._`${i} == 'object' && Array.isArray(${n}) && ${n}.length == 1`, () => s.assign(n, o._`${n}[0]`).assign(i, o._`typeof ${n}`).if(h(t, n, a.strictNumbers), () => s.assign(c, n))); s.if(o._`${c} !== undefined`); for (const e of r) (l.has(e) || "array" === e && "array" === a.coerceTypes) && u(e); function u(e) {
                                switch (e) {
                                    case "string": return void s.elseIf(o._`${i} == "number" || ${i} == "boolean"`).assign(c, o._`"" + ${n}`).elseIf(o._`${n} === null`).assign(c, o._`""`); case "number": return void s.elseIf(o._`${i} == "boolean" || ${n} === null
              || (${i} == "string" && ${n} && ${n} == +${n})`).assign(c, o._`+${n}`); case "integer": return void s.elseIf(o._`${i} === "boolean" || ${n} === null
              || (${i} === "string" && ${n} && ${n} == +${n} && !(${n} % 1))`).assign(c, o._`+${n}`); case "boolean": return void s.elseIf(o._`${n} === "false" || ${n} === 0 || ${n} === null`).assign(c, !1).elseIf(o._`${n} === "true" || ${n} === 1`).assign(c, !0); case "null": return s.elseIf(o._`${n} === "" || ${n} === 0 || ${n} === false`), void s.assign(c, null); case "array": s.elseIf(o._`${i} === "string" || ${i} === "number"
              || ${i} === "boolean" || ${n} === null`).assign(c, o._`[${n}]`)
                                }
                            } s.else(), f(e), s.endIf(), s.if(o._`${c} !== undefined`, () => { s.assign(n, c), function ({ gen: e, parentData: t, parentDataProperty: r }, s) { e.if(o._`${t} !== undefined`, () => e.assign(o._`${t}[${r}]`, s)) }(e, c) })
                        }(e, t, i) : f(e)
                    })
                } return u
            }; const l = new Set(["string", "number", "integer", "boolean", "null"]); function d(e, t, r, s = c.Correct) { const n = s === c.Correct ? o.operators.EQ : o.operators.NEQ; let a; switch (e) { case "null": return o._`${t} ${n} null`; case "array": a = o._`Array.isArray(${t})`; break; case "object": a = o._`${t} && typeof ${t} == "object" && !Array.isArray(${t})`; break; case "integer": a = i(o._`!(${t} % 1) && !isNaN(${t})`); break; case "number": a = i(); break; default: return o._`typeof ${t} ${n} ${e}` }return s === c.Correct ? a : (0, o.not)(a); function i(e = o.nil) { return (0, o.and)(o._`typeof ${t} == "number"`, e, r ? o._`isFinite(${t})` : o.nil) } } function h(e, t, r, s) { if (1 === e.length) return d(e[0], t, r, s); let n; const a = (0, i.toHash)(e); if (a.array && a.object) { const e = o._`typeof ${t} != "object"`; n = a.null ? e : o._`!${t} || ${e}`, delete a.null, delete a.array, delete a.object } else n = o.nil; a.number && delete a.integer; for (const e in a) n = (0, o.and)(n, d(e, t, r, s)); return n } t.checkDataType = d, t.checkDataTypes = h; const m = { message: ({ schema: e }) => `must be ${e}`, params: ({ schema: e, schemaValue: t }) => "string" == typeof e ? o._`{type: ${e}}` : o._`{type: ${t}}` }; function f(e) { const t = function (e) { const { gen: t, data: r, schema: s } = e, n = (0, i.schemaRefOrVal)(e, s, "type"); return { gen: t, keyword: "type", data: r, schema: s.type, schemaCode: n, schemaValue: n, parentSchema: s, params: {}, it: e } }(e); (0, a.reportError)(t, m) } t.reportTypeError = f
        }, 343: e => { const t = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, r = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu; function s(e) { return "boolean" == typeof e.secure ? e.secure : "wss" === String(e.scheme).toLowerCase() } function n(e) { return e.host || (e.error = e.error || "HTTP URIs must have a host."), e } function a(e) { const t = "https" === String(e.scheme).toLowerCase(); return e.port !== (t ? 443 : 80) && "" !== e.port || (e.port = void 0), e.path || (e.path = "/"), e } const o = { scheme: "http", domainHost: !0, parse: n, serialize: a }, i = { scheme: "ws", domainHost: !0, parse: function (e) { return e.secure = s(e), e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""), e.path = void 0, e.query = void 0, e }, serialize: function (e) { if (e.port !== (s(e) ? 443 : 80) && "" !== e.port || (e.port = void 0), "boolean" == typeof e.secure && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) { const [t, r] = e.resourceName.split("?"); e.path = t && "/" !== t ? t : void 0, e.query = r, e.resourceName = void 0 } return e.fragment = void 0, e } }, c = { http: o, https: { scheme: "https", domainHost: o.domainHost, parse: n, serialize: a }, ws: i, wss: { scheme: "wss", domainHost: i.domainHost, parse: i.parse, serialize: i.serialize }, urn: { scheme: "urn", parse: function (e, t) { if (!e.path) return e.error = "URN can not be parsed", e; const s = e.path.match(r); if (s) { const r = t.scheme || e.scheme || "urn"; e.nid = s[1].toLowerCase(), e.nss = s[2]; const n = `${r}:${t.nid || e.nid}`, a = c[n]; e.path = void 0, a && (e = a.parse(e, t)) } else e.error = e.error || "URN can not be parsed."; return e }, serialize: function (e, t) { const r = t.scheme || e.scheme || "urn", s = e.nid.toLowerCase(), n = `${r}:${t.nid || s}`, a = c[n]; a && (e = a.serialize(e, t)); const o = e, i = e.nss; return o.path = `${s || t.nid}:${i}`, t.skipEscape = !0, o }, skipNormalize: !0 }, "urn:uuid": { scheme: "urn:uuid", parse: function (e, r) { const s = e; return s.uuid = s.nss, s.nss = void 0, r.tolerant || s.uuid && t.test(s.uuid) || (s.error = s.error || "UUID is not valid."), s }, serialize: function (e) { const t = e; return t.nss = (e.uuid || "").toLowerCase(), t }, skipNormalize: !0 } }; e.exports = c }, 392: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = r(2023), o = { keyword: "unevaluatedProperties", type: "object", schemaType: ["boolean", "object"], trackErrors: !0, error: { message: "must NOT have unevaluated properties", params: ({ params: e }) => s._`{unevaluatedProperty: ${e.unevaluatedProperty}}` }, code(e) { const { gen: t, schema: r, data: o, errsCount: i, it: c } = e; if (!i) throw new Error("ajv implementation error"); const { allErrors: u, props: l } = c; function d(a) { if (!1 === r) return e.setParams({ unevaluatedProperty: a }), e.error(), void (u || t.break()); if (!(0, n.alwaysValidSchema)(c, r)) { const r = t.name("valid"); e.subschema({ keyword: "unevaluatedProperties", dataProp: a, dataPropType: n.Type.Str }, r), u || t.if((0, s.not)(r), () => t.break()) } } l instanceof s.Name ? t.if(s._`${l} !== true`, () => t.forIn("key", o, e => t.if(function (e, t) { return s._`!${e} || !${e}[${t}]` }(l, e), () => d(e)))) : !0 !== l && t.forIn("key", o, e => void 0 === l ? d(e) : t.if(function (e, t) { const r = []; for (const n in e) !0 === e[n] && r.push(s._`${t} !== ${n}`); return (0, s.and)(...r) }(l, e), () => d(e))), c.props = !0, e.ok(s._`${i} === ${a.default.errors}`) } }; t.default = o }, 396: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.getRules = t.isJSONType = void 0; const r = new Set(["string", "number", "integer", "boolean", "null", "object", "array"]); t.isJSONType = function (e) { return "string" == typeof e && r.has(e) }, t.getRules = function () { const e = { number: { type: "number", rules: [] }, string: { type: "string", rules: [] }, array: { type: "array", rules: [] }, object: { type: "object", rules: [] } }; return { types: { ...e, integer: !0, boolean: !0, null: !0 }, rules: [{ rules: [] }, e.number, e.string, e.array, e.object], post: { rules: [] }, all: {}, keywords: {} } } }, 422: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(5765), n = r(9029), a = { keyword: "pattern", type: "string", schemaType: "string", $data: !0, error: { message: ({ schemaCode: e }) => n.str`must match pattern "${e}"`, params: ({ schemaCode: e }) => n._`{pattern: ${e}}` }, code(e) { const { data: t, $data: r, schema: a, schemaCode: o, it: i } = e, c = i.opts.unicodeRegExp ? "u" : "", u = r ? n._`(new RegExp(${o}, ${c}))` : (0, s.usePattern)(e, a); e.fail$data(n._`!${u}.test(${t})`) } }; t.default = a }, 494: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.validateTuple = void 0; const s = r(9029), n = r(4227), a = r(5765), o = { keyword: "items", type: "array", schemaType: ["object", "array", "boolean"], before: "uniqueItems", code(e) { const { schema: t, it: r } = e; if (Array.isArray(t)) return i(e, "additionalItems", t); r.items = !0, (0, n.alwaysValidSchema)(r, t) || e.ok((0, a.validateArray)(e)) } }; function i(e, t, r = e.schema) { const { gen: a, parentSchema: o, data: i, keyword: c, it: u } = e; !function (e) { const { opts: s, errSchemaPath: a } = u, o = r.length, i = o === e.minItems && (o === e.maxItems || !1 === e[t]); if (s.strictTuples && !i) { const e = `"${c}" is ${o}-tuple, but minItems or maxItems/${t} are not specified or different at path "${a}"`; (0, n.checkStrictMode)(u, e, s.strictTuples) } }(o), u.opts.unevaluated && r.length && !0 !== u.items && (u.items = n.mergeEvaluated.items(a, r.length, u.items)); const l = a.name("valid"), d = a.const("len", s._`${i}.length`); r.forEach((t, r) => { (0, n.alwaysValidSchema)(u, t) || (a.if(s._`${d} > ${r}`, () => e.subschema({ keyword: c, schemaProp: r, dataProp: r }, l)), e.ok(l)) }) } t.validateTuple = i, t.default = o }, 617: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(208), n = r(9029), a = r(4227), o = r(6250), i = { keyword: "uniqueItems", type: "array", schemaType: "boolean", $data: !0, error: { message: ({ params: { i: e, j: t } }) => n.str`must NOT have duplicate items (items ## ${t} and ${e} are identical)`, params: ({ params: { i: e, j: t } }) => n._`{i: ${e}, j: ${t}}` }, code(e) { const { gen: t, data: r, $data: i, schema: c, parentSchema: u, schemaCode: l, it: d } = e; if (!i && !c) return; const h = t.let("valid"), m = u.items ? (0, s.getSchemaTypes)(u.items) : []; function f(a, o) { const i = t.name("item"), c = (0, s.checkDataTypes)(m, i, d.opts.strictNumbers, s.DataType.Wrong), u = t.const("indices", n._`{}`); t.for(n._`;${a}--;`, () => { t.let(i, n._`${r}[${a}]`), t.if(c, n._`continue`), m.length > 1 && t.if(n._`typeof ${i} == "string"`, n._`${i} += "_"`), t.if(n._`typeof ${u}[${i}] == "number"`, () => { t.assign(o, n._`${u}[${i}]`), e.error(), t.assign(h, !1).break() }).code(n._`${u}[${i}] = ${a}`) }) } function p(s, i) { const c = (0, a.useFunc)(t, o.default), u = t.name("outer"); t.label(u).for(n._`;${s}--;`, () => t.for(n._`${i} = ${s}; ${i}--;`, () => t.if(n._`${c}(${r}[${s}], ${r}[${i}])`, () => { e.error(), t.assign(h, !1).break(u) }))) } e.block$data(h, function () { const s = t.let("i", n._`${r}.length`), a = t.let("j"); e.setParams({ i: s, j: a }), t.assign(h, !0), t.if(n._`${s} > 1`, () => (m.length > 0 && !m.some(e => "object" === e || "array" === e) ? f : p)(s, a)) }, n._`${l} === false`), e.ok(h) } }; t.default = i }, 711: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/meta/meta-data","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/meta-data":true},"$recursiveAnchor":true,"title":"Meta-data vocabulary meta-schema","type":["object","boolean"],"properties":{"title":{"type":"string"},"description":{"type":"string"},"default":true,"deprecated":{"type":"boolean","default":false},"readOnly":{"type":"boolean","default":false},"writeOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true}}}') }, 958: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/meta/content","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/content":true},"$recursiveAnchor":true,"title":"Content vocabulary meta-schema","type":["object","boolean"],"properties":{"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"contentSchema":{"$recursiveRef":"#"}}}') }, 1024: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(8138), n = r(4908), a = r(958), o = r(58), i = r(6534), c = r(711), u = r(8030), l = ["/properties"]; t.default = function (e) { return [s, n, a, o, t(this, i), c, t(this, u)].forEach(e => this.addMetaSchema(e, void 0, !1)), this; function t(t, r) { return e ? t.$dataMetaSchema(r, l) : r } } }, 1163: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = { keyword: ["maxItems", "minItems"], type: "array", schemaType: "number", $data: !0, error: { message({ keyword: e, schemaCode: t }) { const r = "maxItems" === e ? "more" : "fewer"; return s.str`must NOT have ${r} than ${t} items` }, params: ({ schemaCode: e }) => s._`{limit: ${e}}` }, code(e) { const { keyword: t, data: r, schemaCode: n } = e, a = "maxItems" === t ? s.operators.GT : s.operators.LT; e.fail$data(s._`${r}.length ${a} ${n}`) } }; t.default = n }, 1239: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = { keyword: "if", schemaType: ["object", "boolean"], trackErrors: !0, error: { message: ({ params: e }) => s.str`must match "${e.ifClause}" schema`, params: ({ params: e }) => s._`{failingKeyword: ${e.ifClause}}` }, code(e) { const { gen: t, parentSchema: r, it: a } = e; void 0 === r.then && void 0 === r.else && (0, n.checkStrictMode)(a, '"if" without "then" and "else" is ignored'); const i = o(a, "then"), c = o(a, "else"); if (!i && !c) return; const u = t.let("valid", !0), l = t.name("_valid"); if (function () { const t = e.subschema({ keyword: "if", compositeRule: !0, createErrors: !1, allErrors: !1 }, l); e.mergeEvaluated(t) }(), e.reset(), i && c) { const r = t.let("ifClause"); e.setParams({ ifClause: r }), t.if(l, d("then", r), d("else", r)) } else i ? t.if(l, d("then")) : t.if((0, s.not)(l), d("else")); function d(r, n) { return () => { const a = e.subschema({ keyword: r }, l); t.assign(u, l), e.mergeValidEvaluated(a, u), n ? t.assign(n, s._`${r}`) : e.setParams({ ifClause: r }) } } e.pass(u, () => e.error(!0)) } }; function o(e, t) { const r = e.schema[t]; return void 0 !== r && !(0, n.alwaysValidSchema)(e, r) } t.default = a }, 1520: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0; class r { } t._CodeOrName = r, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i; class s extends r { constructor(e) { if (super(), !t.IDENTIFIER.test(e)) throw new Error("CodeGen: name must be a valid identifier"); this.str = e } toString() { return this.str } emptyStr() { return !1 } get names() { return { [this.str]: 1 } } } t.Name = s; class n extends r { constructor(e) { super(), this._items = "string" == typeof e ? [e] : e } toString() { return this.str } emptyStr() { if (this._items.length > 1) return !1; const e = this._items[0]; return "" === e || '""' === e } get str() { var e; return null !== (e = this._str) && void 0 !== e ? e : this._str = this._items.reduce((e, t) => `${e}${t}`, "") } get names() { var e; return null !== (e = this._names) && void 0 !== e ? e : this._names = this._items.reduce((e, t) => (t instanceof s && (e[t.str] = (e[t.str] || 0) + 1), e), {}) } } function a(e, ...t) { const r = [e[0]]; let s = 0; for (; s < t.length;)c(r, t[s]), r.push(e[++s]); return new n(r) } t._Code = n, t.nil = new n(""), t._ = a; const o = new n("+"); function i(e, ...t) { const r = [l(e[0])]; let s = 0; for (; s < t.length;)r.push(o), c(r, t[s]), r.push(o, l(e[++s])); return function (e) { let t = 1; for (; t < e.length - 1;) { if (e[t] === o) { const r = u(e[t - 1], e[t + 1]); if (void 0 !== r) { e.splice(t - 1, 3, r); continue } e[t++] = "+" } t++ } }(r), new n(r) } function c(e, t) { var r; t instanceof n ? e.push(...t._items) : t instanceof s ? e.push(t) : e.push("number" == typeof (r = t) || "boolean" == typeof r || null === r ? r : l(Array.isArray(r) ? r.join(",") : r)) } function u(e, t) { if ('""' === t) return e; if ('""' === e) return t; if ("string" == typeof e) { if (t instanceof s || '"' !== e[e.length - 1]) return; return "string" != typeof t ? `${e.slice(0, -1)}${t}"` : '"' === t[0] ? e.slice(0, -1) + t.slice(1) : void 0 } return "string" != typeof t || '"' !== t[0] || e instanceof s ? void 0 : `"${e}${t.slice(1)}` } function l(e) { return JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") } t.str = i, t.addCodeArg = c, t.strConcat = function (e, t) { return t.emptyStr() ? e : e.emptyStr() ? t : i`${e}${t}` }, t.stringify = function (e) { return new n(l(e)) }, t.safeStringify = l, t.getProperty = function (e) { return "string" == typeof e && t.IDENTIFIER.test(e) ? new n(`.${e}`) : a`[${e}]` }, t.getEsmExportName = function (e) { if ("string" == typeof e && t.IDENTIFIER.test(e)) return new n(`${e}`); throw new Error(`CodeGen: invalid export name: ${e}, use explicit $id name mapping`) }, t.regexpCode = function (e) { return new n(e.toString()) } }, 1846: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(3025), n = { keyword: "dependentRequired", type: "object", schemaType: "object", error: s.error, code: e => (0, s.validatePropertyDeps)(e) }; t.default = n }, 2017: e => { e.exports = function e(t, r) { if (t === r) return !0; if (t && r && "object" == typeof t && "object" == typeof r) { if (t.constructor !== r.constructor) return !1; var s, n, a; if (Array.isArray(t)) { if ((s = t.length) != r.length) return !1; for (n = s; 0 !== n--;)if (!e(t[n], r[n])) return !1; return !0 } if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags; if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf(); if (t.toString !== Object.prototype.toString) return t.toString() === r.toString(); if ((s = (a = Object.keys(t)).length) !== Object.keys(r).length) return !1; for (n = s; 0 !== n--;)if (!Object.prototype.hasOwnProperty.call(r, a[n])) return !1; for (n = s; 0 !== n--;) { var o = a[n]; if (!e(t[o], r[o])) return !1 } return !0 } return t != t && r != r } }, 2023: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = { data: new s.Name("data"), valCxt: new s.Name("valCxt"), instancePath: new s.Name("instancePath"), parentData: new s.Name("parentData"), parentDataProperty: new s.Name("parentDataProperty"), rootData: new s.Name("rootData"), dynamicAnchors: new s.Name("dynamicAnchors"), vErrors: new s.Name("vErrors"), errors: new s.Name("errors"), this: new s.Name("this"), self: new s.Name("self"), scope: new s.Name("scope"), json: new s.Name("json"), jsonPos: new s.Name("jsonPos"), jsonLen: new s.Name("jsonLen"), jsonPart: new s.Name("jsonPart") }; t.default = n }, 2079: e => { e.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}') }, 2128: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(3463), n = r(3693), a = ["$schema", "$id", "$defs", "$vocabulary", { keyword: "$comment" }, "definitions", s.default, n.default]; t.default = a }, 2476: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.dynamicAnchor = void 0; const s = r(9029), n = r(2023), a = r(3835), o = r(3693), i = { keyword: "$dynamicAnchor", schemaType: "string", code: e => c(e, e.schema) }; function c(e, t) { const { gen: r, it: i } = e; i.schemaEnv.root.dynamicAnchors[t] = !0; const c = s._`${n.default.dynamicAnchors}${(0, s.getProperty)(t)}`, u = "#" === i.errSchemaPath ? i.validateName : function (e) { const { schemaEnv: t, schema: r, self: s } = e.it, { root: n, baseId: i, localRefs: c, meta: u } = t.root, { schemaId: l } = s.opts, d = new a.SchemaEnv({ schema: r, schemaId: l, root: n, baseId: i, localRefs: c, meta: u }); return a.compileSchema.call(s, d), (0, o.getValidate)(e, d) }(e); r.if(s._`!${c}`, () => r.assign(c, u)) } t.dynamicAnchor = c, t.default = i }, 2586: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.getData = t.KeywordCxt = t.validateFunctionCode = void 0; const s = r(8727), n = r(208), a = r(7887), o = r(208), i = r(7870), c = r(3673), u = r(4495), l = r(9029), d = r(2023), h = r(6939), m = r(4227), f = r(8708); function p({ gen: e, validateName: t, schema: r, schemaEnv: s, opts: n }, a) { n.code.es5 ? e.func(t, l._`${d.default.data}, ${d.default.valCxt}`, s.$async, () => { e.code(l._`"use strict"; ${y(r, n)}`), function (e, t) { e.if(d.default.valCxt, () => { e.var(d.default.instancePath, l._`${d.default.valCxt}.${d.default.instancePath}`), e.var(d.default.parentData, l._`${d.default.valCxt}.${d.default.parentData}`), e.var(d.default.parentDataProperty, l._`${d.default.valCxt}.${d.default.parentDataProperty}`), e.var(d.default.rootData, l._`${d.default.valCxt}.${d.default.rootData}`), t.dynamicRef && e.var(d.default.dynamicAnchors, l._`${d.default.valCxt}.${d.default.dynamicAnchors}`) }, () => { e.var(d.default.instancePath, l._`""`), e.var(d.default.parentData, l._`undefined`), e.var(d.default.parentDataProperty, l._`undefined`), e.var(d.default.rootData, d.default.data), t.dynamicRef && e.var(d.default.dynamicAnchors, l._`{}`) }) }(e, n), e.code(a) }) : e.func(t, l._`${d.default.data}, ${function (e) { return l._`{${d.default.instancePath}="", ${d.default.parentData}, ${d.default.parentDataProperty}, ${d.default.rootData}=${d.default.data}${e.dynamicRef ? l._`, ${d.default.dynamicAnchors}={}` : l.nil}}={}` }(n)}`, s.$async, () => e.code(y(r, n)).code(a)) } function y(e, t) { const r = "object" == typeof e && e[t.schemaId]; return r && (t.code.source || t.code.process) ? l._`/*# sourceURL=${r} */` : l.nil } function g(e, t) { $(e) && (w(e), v(e)) ? function (e, t) { const { schema: r, gen: s, opts: n } = e; n.$comment && r.$comment && _(e); (function (e) { const t = e.schema[e.opts.schemaId]; t && (e.baseId = (0, h.resolveUrl)(e.opts.uriResolver, e.baseId, t)) })(e), function (e) { if (e.schema.$async && !e.schemaEnv.$async) throw new Error("async schema in sync schema") }(e); const a = s.const("_errs", d.default.errors); b(e, a), s.var(t, l._`${a} === ${d.default.errors}`) }(e, t) : (0, s.boolOrEmptySchema)(e, t) } function v({ schema: e, self: t }) { if ("boolean" == typeof e) return !e; for (const r in e) if (t.RULES.all[r]) return !0; return !1 } function $(e) { return "boolean" != typeof e.schema } function w(e) { (0, m.checkUnknownRules)(e), function (e) { const { schema: t, errSchemaPath: r, opts: s, self: n } = e; t.$ref && s.ignoreKeywordsWithRef && (0, m.schemaHasRulesButRef)(t, n.RULES) && n.logger.warn(`$ref: keywords ignored in schema at path "${r}"`) }(e) } function b(e, t) { if (e.opts.jtd) return k(e, [], !1, t); const r = (0, n.getSchemaTypes)(e.schema); k(e, r, !(0, n.coerceAndCheckDataType)(e, r), t) } function _({ gen: e, schemaEnv: t, schema: r, errSchemaPath: s, opts: n }) { const a = r.$comment; if (!0 === n.$comment) e.code(l._`${d.default.self}.logger.log(${a})`); else if ("function" == typeof n.$comment) { const r = l.str`${s}/$comment`, n = e.scopeValue("root", { ref: t.root }); e.code(l._`${d.default.self}.opts.$comment(${a}, ${r}, ${n}.schema)`) } } function k(e, t, r, s) { const { gen: n, schema: i, data: c, allErrors: u, opts: h, self: f } = e, { RULES: p } = f; function y(m) { (0, a.shouldUseGroup)(i, m) && (m.type ? (n.if((0, o.checkDataType)(m.type, c, h.strictNumbers)), S(e, m), 1 === t.length && t[0] === m.type && r && (n.else(), (0, o.reportTypeError)(e)), n.endIf()) : S(e, m), u || n.if(l._`${d.default.errors} === ${s || 0}`)) } !i.$ref || !h.ignoreKeywordsWithRef && (0, m.schemaHasRulesButRef)(i, p) ? (h.jtd || function (e, t) { if (e.schemaEnv.meta || !e.opts.strictTypes) return; (function (e, t) { if (!t.length) return; if (!e.dataTypes.length) return void (e.dataTypes = t); t.forEach(t => { O(e.dataTypes, t) || E(e, `type "${t}" not allowed by context "${e.dataTypes.join(",")}"`) }), function (e, t) { const r = []; for (const s of e.dataTypes) O(t, s) ? r.push(s) : t.includes("integer") && "number" === s && r.push("integer"); e.dataTypes = r }(e, t) })(e, t), e.opts.allowUnionTypes || function (e, t) { t.length > 1 && (2 !== t.length || !t.includes("null")) && E(e, "use allowUnionTypes to allow union type keyword") }(e, t); !function (e, t) { const r = e.self.RULES.all; for (const s in r) { const n = r[s]; if ("object" == typeof n && (0, a.shouldUseRule)(e.schema, n)) { const { type: r } = n.definition; r.length && !r.some(e => N(t, e)) && E(e, `missing type "${r.join(",")}" for keyword "${s}"`) } } }(e, e.dataTypes) }(e, t), n.block(() => { for (const e of p.rules) y(e); y(p.post) })) : n.block(() => j(e, "$ref", p.all.$ref.definition)) } function S(e, t) { const { gen: r, schema: s, opts: { useDefaults: n } } = e; n && (0, i.assignDefaults)(e, t.type), r.block(() => { for (const r of t.rules) (0, a.shouldUseRule)(s, r) && j(e, r.keyword, r.definition, t.type) }) } function N(e, t) { return e.includes(t) || "number" === t && e.includes("integer") } function O(e, t) { return e.includes(t) || "integer" === t && e.includes("number") } function E(e, t) { t += ` at "${e.schemaEnv.baseId + e.errSchemaPath}" (strictTypes)`, (0, m.checkStrictMode)(e, t, e.opts.strictTypes) } t.validateFunctionCode = function (e) { $(e) && (w(e), v(e)) ? function (e) { const { schema: t, opts: r, gen: s } = e; p(e, () => { r.$comment && t.$comment && _(e), function (e) { const { schema: t, opts: r } = e; void 0 !== t.default && r.useDefaults && r.strictSchema && (0, m.checkStrictMode)(e, "default is ignored in the schema root") }(e), s.let(d.default.vErrors, null), s.let(d.default.errors, 0), r.unevaluated && function (e) { const { gen: t, validateName: r } = e; e.evaluated = t.const("evaluated", l._`${r}.evaluated`), t.if(l._`${e.evaluated}.dynamicProps`, () => t.assign(l._`${e.evaluated}.props`, l._`undefined`)), t.if(l._`${e.evaluated}.dynamicItems`, () => t.assign(l._`${e.evaluated}.items`, l._`undefined`)) }(e), b(e), function (e) { const { gen: t, schemaEnv: r, validateName: s, ValidationError: n, opts: a } = e; r.$async ? t.if(l._`${d.default.errors} === 0`, () => t.return(d.default.data), () => t.throw(l._`new ${n}(${d.default.vErrors})`)) : (t.assign(l._`${s}.errors`, d.default.vErrors), a.unevaluated && function ({ gen: e, evaluated: t, props: r, items: s }) { r instanceof l.Name && e.assign(l._`${t}.props`, r); s instanceof l.Name && e.assign(l._`${t}.items`, s) }(e), t.return(l._`${d.default.errors} === 0`)) }(e) }) }(e) : p(e, () => (0, s.topBoolOrEmptySchema)(e)) }; class P { constructor(e, t, r) { if ((0, c.validateKeywordUsage)(e, t, r), this.gen = e.gen, this.allErrors = e.allErrors, this.keyword = r, this.data = e.data, this.schema = e.schema[r], this.$data = t.$data && e.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, m.schemaRefOrVal)(e, this.schema, r, this.$data), this.schemaType = t.schemaType, this.parentSchema = e.schema, this.params = {}, this.it = e, this.def = t, this.$data) this.schemaCode = e.gen.const("vSchema", I(this.$data, e)); else if (this.schemaCode = this.schemaValue, !(0, c.validSchemaType)(this.schema, t.schemaType, t.allowUndefined)) throw new Error(`${r} value must be ${JSON.stringify(t.schemaType)}`); ("code" in t ? t.trackErrors : !1 !== t.errors) && (this.errsCount = e.gen.const("_errs", d.default.errors)) } result(e, t, r) { this.failResult((0, l.not)(e), t, r) } failResult(e, t, r) { this.gen.if(e), r ? r() : this.error(), t ? (this.gen.else(), t(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else() } pass(e, t) { this.failResult((0, l.not)(e), void 0, t) } fail(e) { if (void 0 === e) return this.error(), void (this.allErrors || this.gen.if(!1)); this.gen.if(e), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else() } fail$data(e) { if (!this.$data) return this.fail(e); const { schemaCode: t } = this; this.fail(l._`${t} !== undefined && (${(0, l.or)(this.invalid$data(), e)})`) } error(e, t, r) { if (t) return this.setParams(t), this._error(e, r), void this.setParams({}); this._error(e, r) } _error(e, t) { (e ? f.reportExtraError : f.reportError)(this, this.def.error, t) } $dataError() { (0, f.reportError)(this, this.def.$dataError || f.keyword$DataError) } reset() { if (void 0 === this.errsCount) throw new Error('add "trackErrors" to keyword definition'); (0, f.resetErrorsCount)(this.gen, this.errsCount) } ok(e) { this.allErrors || this.gen.if(e) } setParams(e, t) { t ? Object.assign(this.params, e) : this.params = e } block$data(e, t, r = l.nil) { this.gen.block(() => { this.check$data(e, r), t() }) } check$data(e = l.nil, t = l.nil) { if (!this.$data) return; const { gen: r, schemaCode: s, schemaType: n, def: a } = this; r.if((0, l.or)(l._`${s} === undefined`, t)), e !== l.nil && r.assign(e, !0), (n.length || a.validateSchema) && (r.elseIf(this.invalid$data()), this.$dataError(), e !== l.nil && r.assign(e, !1)), r.else() } invalid$data() { const { gen: e, schemaCode: t, schemaType: r, def: s, it: n } = this; return (0, l.or)(function () { if (r.length) { if (!(t instanceof l.Name)) throw new Error("ajv implementation error"); const e = Array.isArray(r) ? r : [r]; return l._`${(0, o.checkDataTypes)(e, t, n.opts.strictNumbers, o.DataType.Wrong)}` } return l.nil }(), function () { if (s.validateSchema) { const r = e.scopeValue("validate$data", { ref: s.validateSchema }); return l._`!${r}(${t})` } return l.nil }()) } subschema(e, t) { const r = (0, u.getSubschema)(this.it, e); (0, u.extendSubschemaData)(r, this.it, e), (0, u.extendSubschemaMode)(r, e); const s = { ...this.it, ...r, items: void 0, props: void 0 }; return g(s, t), s } mergeEvaluated(e, t) { const { it: r, gen: s } = this; r.opts.unevaluated && (!0 !== r.props && void 0 !== e.props && (r.props = m.mergeEvaluated.props(s, e.props, r.props, t)), !0 !== r.items && void 0 !== e.items && (r.items = m.mergeEvaluated.items(s, e.items, r.items, t))) } mergeValidEvaluated(e, t) { const { it: r, gen: s } = this; if (r.opts.unevaluated && (!0 !== r.props || !0 !== r.items)) return s.if(t, () => this.mergeEvaluated(e, l.Name)), !0 } } function j(e, t, r, s) { const n = new P(e, r, t); "code" in r ? r.code(n, s) : n.$data && r.validate ? (0, c.funcKeywordCode)(n, r) : "macro" in r ? (0, c.macroKeywordCode)(n, r) : (r.compile || r.validate) && (0, c.funcKeywordCode)(n, r) } t.KeywordCxt = P; const T = /^\/(?:[^~]|~0|~1)*$/, x = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/; function I(e, { dataLevel: t, dataNames: r, dataPathArr: s }) { let n, a; if ("" === e) return d.default.rootData; if ("/" === e[0]) { if (!T.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`); n = e, a = d.default.rootData } else { const o = x.exec(e); if (!o) throw new Error(`Invalid JSON-pointer: ${e}`); const i = +o[1]; if (n = o[2], "#" === n) { if (i >= t) throw new Error(c("property/index", i)); return s[t - i] } if (i > t) throw new Error(c("data", i)); if (a = r[t - i], !n) return a } let o = a; const i = n.split("/"); for (const e of i) e && (a = l._`${a}${(0, l.getProperty)((0, m.unescapeJsonPointer)(e))}`, o = l._`${o} && ${a}`); return o; function c(e, r) { return `Cannot access ${e} ${r} levels up, current level is ${t}` } } t.getData = I }, 2626: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(4227), n = { keyword: ["maxContains", "minContains"], type: "array", schemaType: "number", code({ keyword: e, parentSchema: t, it: r }) { void 0 === t.contains && (0, s.checkStrictMode)(r, `"${e}" without "contains" is ignored`) } }; t.default = n }, 2661: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = { keyword: "contains", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", trackErrors: !0, error: { message: ({ params: { min: e, max: t } }) => void 0 === t ? s.str`must contain at least ${e} valid item(s)` : s.str`must contain at least ${e} and no more than ${t} valid item(s)`, params: ({ params: { min: e, max: t } }) => void 0 === t ? s._`{minContains: ${e}}` : s._`{minContains: ${e}, maxContains: ${t}}` }, code(e) { const { gen: t, schema: r, parentSchema: a, data: o, it: i } = e; let c, u; const { minContains: l, maxContains: d } = a; i.opts.next ? (c = void 0 === l ? 1 : l, u = d) : c = 1; const h = t.const("len", s._`${o}.length`); if (e.setParams({ min: c, max: u }), void 0 === u && 0 === c) return void (0, n.checkStrictMode)(i, '"minContains" == 0 without "maxContains": "contains" keyword ignored'); if (void 0 !== u && c > u) return (0, n.checkStrictMode)(i, '"minContains" > "maxContains" is always invalid'), void e.fail(); if ((0, n.alwaysValidSchema)(i, r)) { let t = s._`${h} >= ${c}`; return void 0 !== u && (t = s._`${t} && ${h} <= ${u}`), void e.pass(t) } i.items = !0; const m = t.name("valid"); function f() { const e = t.name("_valid"), r = t.let("count", 0); p(e, () => t.if(e, () => function (e) { t.code(s._`${e}++`), void 0 === u ? t.if(s._`${e} >= ${c}`, () => t.assign(m, !0).break()) : (t.if(s._`${e} > ${u}`, () => t.assign(m, !1).break()), 1 === c ? t.assign(m, !0) : t.if(s._`${e} >= ${c}`, () => t.assign(m, !0))) }(r))) } function p(r, s) { t.forRange("i", 0, h, t => { e.subschema({ keyword: "contains", dataProp: t, dataPropType: n.Type.Num, compositeRule: !0 }, r), s() }) } void 0 === u && 1 === c ? p(m, () => t.if(m, () => t.break())) : 0 === c ? (t.let(m, !0), void 0 !== u && t.if(s._`${o}.length > 0`, f)) : (t.let(m, !1), f()), e.result(m, () => e.reset()) } }; t.default = a }, 2721: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(2476), n = r(4227), a = { keyword: "$recursiveAnchor", schemaType: "boolean", code(e) { e.schema ? (0, s.dynamicAnchor)(e, "") : (0, n.checkStrictMode)(e.it, "$recursiveAnchor: false is ignored") } }; t.default = a }, 3025: (e, t, r) => {
            Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0; const s = r(9029), n = r(4227), a = r(5765); t.error = {
                message: ({ params: { property: e, depsCount: t, deps: r } }) => { const n = 1 === t ? "property" : "properties"; return s.str`must have ${n} ${r} when property ${e} is present` }, params: ({ params: { property: e, depsCount: t, deps: r, missingProperty: n } }) => s._`{property: ${e},
    missingProperty: ${n},
    depsCount: ${t},
    deps: ${r}}`
            }; const o = { keyword: "dependencies", type: "object", schemaType: "object", error: t.error, code(e) { const [t, r] = function ({ schema: e }) { const t = {}, r = {}; for (const s in e) { if ("__proto__" === s) continue; (Array.isArray(e[s]) ? t : r)[s] = e[s] } return [t, r] }(e); i(e, t), c(e, r) } }; function i(e, t = e.schema) { const { gen: r, data: n, it: o } = e; if (0 === Object.keys(t).length) return; const i = r.let("missing"); for (const c in t) { const u = t[c]; if (0 === u.length) continue; const l = (0, a.propertyInData)(r, n, c, o.opts.ownProperties); e.setParams({ property: c, depsCount: u.length, deps: u.join(", ") }), o.allErrors ? r.if(l, () => { for (const t of u) (0, a.checkReportMissingProp)(e, t) }) : (r.if(s._`${l} && (${(0, a.checkMissingProp)(e, u, i)})`), (0, a.reportMissingProp)(e, i), r.else()) } } function c(e, t = e.schema) { const { gen: r, data: s, keyword: o, it: i } = e, c = r.name("valid"); for (const u in t) (0, n.alwaysValidSchema)(i, t[u]) || (r.if((0, a.propertyInData)(r, s, u, i.opts.ownProperties), () => { const t = e.subschema({ keyword: o, schemaProp: u }, c); e.mergeValidEvaluated(t, c) }, () => r.var(c, !0)), e.ok(c)) } t.validatePropertyDeps = i, t.validateSchemaDeps = c, t.default = o
        }, 3252: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.dynamicRef = void 0; const s = r(9029), n = r(2023), a = r(3693), o = { keyword: "$dynamicRef", schemaType: "string", code: e => i(e, e.schema) }; function i(e, t) { const { gen: r, keyword: o, it: i } = e; if ("#" !== t[0]) throw new Error(`"${o}" only supports hash fragment reference`); const c = t.slice(1); if (i.allErrors) u(); else { const t = r.let("valid", !1); u(t), e.ok(t) } function u(e) { if (i.schemaEnv.root.dynamicAnchors[c]) { const t = r.let("_v", s._`${n.default.dynamicAnchors}${(0, s.getProperty)(c)}`); r.if(t, l(t, e), l(i.validateName, e)) } else l(i.validateName, e)() } function l(t, s) { return s ? () => r.block(() => { (0, a.callRef)(e, t), r.let(s, !0) }) : () => (0, a.callRef)(e, t) } } t.dynamicRef = i, t.default = o }, 3265: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(392), n = r(3445), a = [s.default, n.default]; t.default = a }, 3282: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0; const s = r(4042), n = r(6144), a = r(6653), o = r(2079), i = ["/properties"], c = "http://json-schema.org/draft-07/schema"; class u extends s.default { _addVocabularies() { super._addVocabularies(), n.default.forEach(e => this.addVocabulary(e)), this.opts.discriminator && this.addKeyword(a.default) } _addDefaultMetaSchema() { if (super._addDefaultMetaSchema(), !this.opts.meta) return; const e = this.opts.$data ? this.$dataMetaSchema(o, i) : o; this.addMetaSchema(e, c, !1), this.refs["http://json-schema.org/schema"] = c } defaultMeta() { return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : void 0) } } t.Ajv = u, e.exports = t = u, e.exports.Ajv = u, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = u; var l = r(2586); Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function () { return l.KeywordCxt } }); var d = r(9029); Object.defineProperty(t, "_", { enumerable: !0, get: function () { return d._ } }), Object.defineProperty(t, "str", { enumerable: !0, get: function () { return d.str } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function () { return d.stringify } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function () { return d.nil } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function () { return d.Name } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function () { return d.CodeGen } }); var h = r(3558); Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function () { return h.default } }); var m = r(4551); Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function () { return m.default } }) }, 3439: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = { keyword: "multipleOf", type: "number", schemaType: "number", $data: !0, error: { message: ({ schemaCode: e }) => s.str`must be multiple of ${e}`, params: ({ schemaCode: e }) => s._`{multipleOf: ${e}}` }, code(e) { const { gen: t, data: r, schemaCode: n, it: a } = e, o = a.opts.multipleOfPrecision, i = t.let("res"), c = o ? s._`Math.abs(Math.round(${i}) - ${i}) > 1e-${o}` : s._`${i} !== parseInt(${i})`; e.fail$data(s._`(${n} === 0 || (${i} = ${r}/${n}, ${c}))`) } }; t.default = n }, 3445: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = { keyword: "unevaluatedItems", type: "array", schemaType: ["boolean", "object"], error: { message: ({ params: { len: e } }) => s.str`must NOT have more than ${e} items`, params: ({ params: { len: e } }) => s._`{limit: ${e}}` }, code(e) { const { gen: t, schema: r, data: a, it: o } = e, i = o.items || 0; if (!0 === i) return; const c = t.const("len", s._`${a}.length`); if (!1 === r) e.setParams({ len: i }), e.fail(s._`${c} > ${i}`); else if ("object" == typeof r && !(0, n.alwaysValidSchema)(o, r)) { const r = t.var("valid", s._`${c} <= ${i}`); t.if((0, s.not)(r), () => function (r, a) { t.forRange("i", a, c, a => { e.subschema({ keyword: "unevaluatedItems", dataProp: a, dataPropType: n.Type.Num }, r), o.allErrors || t.if((0, s.not)(r), () => t.break()) }) }(r, i)), e.ok(r) } o.items = !0 } }; t.default = a }, 3463: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }); const r = { keyword: "id", code() { throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID') } }; t.default = r }, 3558: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }); class r extends Error { constructor(e) { super("validation failed"), this.errors = e, this.ajv = this.validation = !0 } } t.default = r }, 3673: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.validateKeywordUsage = t.validSchemaType = t.funcKeywordCode = t.macroKeywordCode = void 0; const s = r(9029), n = r(2023), a = r(5765), o = r(8708); function i(e) { const { gen: t, data: r, it: n } = e; t.if(n.parentData, () => t.assign(r, s._`${n.parentData}[${n.parentDataProperty}]`)) } function c(e, t, r) { if (void 0 === r) throw new Error(`keyword "${t}" failed to compile`); return e.scopeValue("keyword", "function" == typeof r ? { ref: r } : { ref: r, code: (0, s.stringify)(r) }) } t.macroKeywordCode = function (e, t) { const { gen: r, keyword: n, schema: a, parentSchema: o, it: i } = e, u = t.macro.call(i.self, a, o, i), l = c(r, n, u); !1 !== i.opts.validateSchema && i.self.validateSchema(u, !0); const d = r.name("valid"); e.subschema({ schema: u, schemaPath: s.nil, errSchemaPath: `${i.errSchemaPath}/${n}`, topSchemaRef: l, compositeRule: !0 }, d), e.pass(d, () => e.error(!0)) }, t.funcKeywordCode = function (e, t) { var r; const { gen: u, keyword: l, schema: d, parentSchema: h, $data: m, it: f } = e; !function ({ schemaEnv: e }, t) { if (t.async && !e.$async) throw new Error("async keyword in sync schema") }(f, t); const p = !m && t.compile ? t.compile.call(f.self, d, h, f) : t.validate, y = c(u, l, p), g = u.let("valid"); function v(r = (t.async ? s._`await ` : s.nil)) { const o = f.opts.passContext ? n.default.this : n.default.self, i = !("compile" in t && !m || !1 === t.schema); u.assign(g, s._`${r}${(0, a.callValidateCode)(e, y, o, i)}`, t.modifying) } function $(e) { var r; u.if((0, s.not)(null !== (r = t.valid) && void 0 !== r ? r : g), e) } e.block$data(g, function () { if (!1 === t.errors) v(), t.modifying && i(e), $(() => e.error()); else { const r = t.async ? function () { const e = u.let("ruleErrs", null); return u.try(() => v(s._`await `), t => u.assign(g, !1).if(s._`${t} instanceof ${f.ValidationError}`, () => u.assign(e, s._`${t}.errors`), () => u.throw(t))), e }() : function () { const e = s._`${y}.errors`; return u.assign(e, null), v(s.nil), e }(); t.modifying && i(e), $(() => function (e, t) { const { gen: r } = e; r.if(s._`Array.isArray(${t})`, () => { r.assign(n.default.vErrors, s._`${n.default.vErrors} === null ? ${t} : ${n.default.vErrors}.concat(${t})`).assign(n.default.errors, s._`${n.default.vErrors}.length`), (0, o.extendErrors)(e) }, () => e.error()) }(e, r)) } }), e.ok(null !== (r = t.valid) && void 0 !== r ? r : g) }, t.validSchemaType = function (e, t, r = !1) { return !t.length || t.some(t => "array" === t ? Array.isArray(e) : "object" === t ? e && "object" == typeof e && !Array.isArray(e) : typeof e == t || r && void 0 === e) }, t.validateKeywordUsage = function ({ schema: e, opts: t, self: r, errSchemaPath: s }, n, a) { if (Array.isArray(n.keyword) ? !n.keyword.includes(a) : n.keyword !== a) throw new Error("ajv implementation error"); const o = n.dependencies; if (null == o ? void 0 : o.some(t => !Object.prototype.hasOwnProperty.call(e, t))) throw new Error(`parent schema must have dependencies of ${a}: ${o.join(",")}`); if (n.validateSchema) { if (!n.validateSchema(e[a])) { const e = `keyword "${a}" value is invalid at path "${s}": ` + r.errorsText(n.validateSchema.errors); if ("log" !== t.validateSchema) throw new Error(e); r.logger.error(e) } } } }, 3693: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.callRef = t.getValidate = void 0; const s = r(4551), n = r(5765), a = r(9029), o = r(2023), i = r(3835), c = r(4227), u = { keyword: "$ref", schemaType: "string", code(e) { const { gen: t, schema: r, it: n } = e, { baseId: o, schemaEnv: c, validateName: u, opts: h, self: m } = n, { root: f } = c; if (("#" === r || "#/" === r) && o === f.baseId) return function () { if (c === f) return d(e, u, c, c.$async); const r = t.scopeValue("root", { ref: f }); return d(e, a._`${r}.validate`, f, f.$async) }(); const p = i.resolveRef.call(m, f, o, r); if (void 0 === p) throw new s.default(n.opts.uriResolver, o, r); return p instanceof i.SchemaEnv ? function (t) { const r = l(e, t); d(e, r, t, t.$async) }(p) : function (s) { const n = t.scopeValue("schema", !0 === h.code.source ? { ref: s, code: (0, a.stringify)(s) } : { ref: s }), o = t.name("valid"), i = e.subschema({ schema: s, dataTypes: [], schemaPath: a.nil, topSchemaRef: n, errSchemaPath: r }, o); e.mergeEvaluated(i), e.ok(o) }(p) } }; function l(e, t) { const { gen: r } = e; return t.validate ? r.scopeValue("validate", { ref: t.validate }) : a._`${r.scopeValue("wrapper", { ref: t })}.validate` } function d(e, t, r, s) { const { gen: i, it: u } = e, { allErrors: l, schemaEnv: d, opts: h } = u, m = h.passContext ? o.default.this : a.nil; function f(e) { const t = a._`${e}.errors`; i.assign(o.default.vErrors, a._`${o.default.vErrors} === null ? ${t} : ${o.default.vErrors}.concat(${t})`), i.assign(o.default.errors, a._`${o.default.vErrors}.length`) } function p(e) { var t; if (!u.opts.unevaluated) return; const s = null === (t = null == r ? void 0 : r.validate) || void 0 === t ? void 0 : t.evaluated; if (!0 !== u.props) if (s && !s.dynamicProps) void 0 !== s.props && (u.props = c.mergeEvaluated.props(i, s.props, u.props)); else { const t = i.var("props", a._`${e}.evaluated.props`); u.props = c.mergeEvaluated.props(i, t, u.props, a.Name) } if (!0 !== u.items) if (s && !s.dynamicItems) void 0 !== s.items && (u.items = c.mergeEvaluated.items(i, s.items, u.items)); else { const t = i.var("items", a._`${e}.evaluated.items`); u.items = c.mergeEvaluated.items(i, t, u.items, a.Name) } } s ? function () { if (!d.$async) throw new Error("async schema referenced by sync schema"); const r = i.let("valid"); i.try(() => { i.code(a._`await ${(0, n.callValidateCode)(e, t, m)}`), p(t), l || i.assign(r, !0) }, e => { i.if(a._`!(${e} instanceof ${u.ValidationError})`, () => i.throw(e)), f(e), l || i.assign(r, !1) }), e.ok(r) }() : e.result((0, n.callValidateCode)(e, t, m), () => p(t), () => f(t)) } t.getValidate = l, t.callRef = d, t.default = u }, 3799: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(3252), n = { keyword: "$recursiveRef", schemaType: "string", code: e => (0, s.dynamicRef)(e, e.schema) }; t.default = n }, 3835: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.resolveSchema = t.getCompilingSchema = t.resolveRef = t.compileSchema = t.SchemaEnv = void 0; const s = r(9029), n = r(3558), a = r(2023), o = r(6939), i = r(4227), c = r(2586); class u { constructor(e) { var t; let r; this.refs = {}, this.dynamicAnchors = {}, "object" == typeof e.schema && (r = e.schema), this.schema = e.schema, this.schemaId = e.schemaId, this.root = e.root || this, this.baseId = null !== (t = e.baseId) && void 0 !== t ? t : (0, o.normalizeId)(null == r ? void 0 : r[e.schemaId || "$id"]), this.schemaPath = e.schemaPath, this.localRefs = e.localRefs, this.meta = e.meta, this.$async = null == r ? void 0 : r.$async, this.refs = {} } } function l(e) { const t = h.call(this, e); if (t) return t; const r = (0, o.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: i, lines: u } = this.opts.code, { ownProperties: l } = this.opts, d = new s.CodeGen(this.scope, { es5: i, lines: u, ownProperties: l }); let m; e.$async && (m = d.scopeValue("Error", { ref: n.default, code: s._`require("ajv/dist/runtime/validation_error").default` })); const f = d.scopeName("validate"); e.validateName = f; const p = { gen: d, allErrors: this.opts.allErrors, data: a.default.data, parentData: a.default.parentData, parentDataProperty: a.default.parentDataProperty, dataNames: [a.default.data], dataPathArr: [s.nil], dataLevel: 0, dataTypes: [], definedProperties: new Set, topSchemaRef: d.scopeValue("schema", !0 === this.opts.code.source ? { ref: e.schema, code: (0, s.stringify)(e.schema) } : { ref: e.schema }), validateName: f, ValidationError: m, schema: e.schema, schemaEnv: e, rootId: r, baseId: e.baseId || r, schemaPath: s.nil, errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"), errorPath: s._`""`, opts: this.opts, self: this }; let y; try { this._compilations.add(e), (0, c.validateFunctionCode)(p), d.optimize(this.opts.code.optimize); const t = d.toString(); y = `${d.scopeRefs(a.default.scope)}return ${t}`, this.opts.code.process && (y = this.opts.code.process(y, e)); const r = new Function(`${a.default.self}`, `${a.default.scope}`, y)(this, this.scope.get()); if (this.scope.value(f, { ref: r }), r.errors = null, r.schema = e.schema, r.schemaEnv = e, e.$async && (r.$async = !0), !0 === this.opts.code.source && (r.source = { validateName: f, validateCode: t, scopeValues: d._values }), this.opts.unevaluated) { const { props: e, items: t } = p; r.evaluated = { props: e instanceof s.Name ? void 0 : e, items: t instanceof s.Name ? void 0 : t, dynamicProps: e instanceof s.Name, dynamicItems: t instanceof s.Name }, r.source && (r.source.evaluated = (0, s.stringify)(r.evaluated)) } return e.validate = r, e } catch (t) { throw delete e.validate, delete e.validateName, y && this.logger.error("Error compiling schema, function code:", y), t } finally { this._compilations.delete(e) } } function d(e) { return (0, o.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : l.call(this, e) } function h(e) { for (const t of this._compilations) if (m(t, e)) return t } function m(e, t) { return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId } function f(e, t) { let r; for (; "string" == typeof (r = this.refs[t]);)t = r; return r || this.schemas[t] || p.call(this, e, t) } function p(e, t) { const r = this.opts.uriResolver.parse(t), s = (0, o._getFullPath)(this.opts.uriResolver, r); let n = (0, o.getFullPath)(this.opts.uriResolver, e.baseId, void 0); if (Object.keys(e.schema).length > 0 && s === n) return g.call(this, r, e); const a = (0, o.normalizeId)(s), i = this.refs[a] || this.schemas[a]; if ("string" == typeof i) { const t = p.call(this, e, i); if ("object" != typeof (null == t ? void 0 : t.schema)) return; return g.call(this, r, t) } if ("object" == typeof (null == i ? void 0 : i.schema)) { if (i.validate || l.call(this, i), a === (0, o.normalizeId)(t)) { const { schema: t } = i, { schemaId: r } = this.opts, s = t[r]; return s && (n = (0, o.resolveUrl)(this.opts.uriResolver, n, s)), new u({ schema: t, schemaId: r, root: e, baseId: n }) } return g.call(this, r, i) } } t.SchemaEnv = u, t.compileSchema = l, t.resolveRef = function (e, t, r) { var s; r = (0, o.resolveUrl)(this.opts.uriResolver, t, r); const n = e.refs[r]; if (n) return n; let a = f.call(this, e, r); if (void 0 === a) { const n = null === (s = e.localRefs) || void 0 === s ? void 0 : s[r], { schemaId: o } = this.opts; n && (a = new u({ schema: n, schemaId: o, root: e, baseId: t })) } return void 0 !== a ? e.refs[r] = d.call(this, a) : void 0 }, t.getCompilingSchema = h, t.resolveSchema = p; const y = new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]); function g(e, { baseId: t, schema: r, root: s }) { var n; if ("/" !== (null === (n = e.fragment) || void 0 === n ? void 0 : n[0])) return; for (const s of e.fragment.slice(1).split("/")) { if ("boolean" == typeof r) return; const e = r[(0, i.unescapeFragment)(s)]; if (void 0 === e) return; const n = "object" == typeof (r = e) && r[this.opts.schemaId]; !y.has(s) && n && (t = (0, o.resolveUrl)(this.opts.uriResolver, t, n)) } let a; if ("boolean" != typeof r && r.$ref && !(0, i.schemaHasRulesButRef)(r, this.RULES)) { const e = (0, o.resolveUrl)(this.opts.uriResolver, t, r.$ref); a = p.call(this, s, e) } const { schemaId: c } = this.opts; return a = a || new u({ schema: r, schemaId: c, root: s, baseId: t }), a.schema !== a.root.schema ? a : void 0 } }, 3837: e => { e.exports = JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}') }, 3853: (e, t) => { function r(e) { const t = e.length; let r, s = 0, n = 0; for (; n < t;)s++, r = e.charCodeAt(n++), r >= 55296 && r <= 56319 && n < t && (r = e.charCodeAt(n), 56320 == (64512 & r) && n++); return s } Object.defineProperty(t, "__esModule", { value: !0 }), t.default = r, r.code = 'require("ajv/dist/runtime/ucs2length").default' }, 3966: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = r(5765), o = r(5457), i = { keyword: "items", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", error: { message: ({ params: { len: e } }) => s.str`must NOT have more than ${e} items`, params: ({ params: { len: e } }) => s._`{limit: ${e}}` }, code(e) { const { schema: t, parentSchema: r, it: s } = e, { prefixItems: i } = r; s.items = !0, (0, n.alwaysValidSchema)(s, t) || (i ? (0, o.validateAdditionalItems)(e, i) : e.ok((0, a.validateArray)(e))) } }; t.default = i }, 4003: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(5765), n = r(9029), a = r(4227), o = { keyword: "required", type: "object", schemaType: "array", $data: !0, error: { message: ({ params: { missingProperty: e } }) => n.str`must have required property '${e}'`, params: ({ params: { missingProperty: e } }) => n._`{missingProperty: ${e}}` }, code(e) { const { gen: t, schema: r, schemaCode: o, data: i, $data: c, it: u } = e, { opts: l } = u; if (!c && 0 === r.length) return; const d = r.length >= l.loopRequired; if (u.allErrors ? function () { if (d || c) e.block$data(n.nil, h); else for (const t of r) (0, s.checkReportMissingProp)(e, t) }() : function () { const a = t.let("missing"); if (d || c) { const r = t.let("valid", !0); e.block$data(r, () => function (r, a) { e.setParams({ missingProperty: r }), t.forOf(r, o, () => { t.assign(a, (0, s.propertyInData)(t, i, r, l.ownProperties)), t.if((0, n.not)(a), () => { e.error(), t.break() }) }, n.nil) }(a, r)), e.ok(r) } else t.if((0, s.checkMissingProp)(e, r, a)), (0, s.reportMissingProp)(e, a), t.else() }(), l.strictRequired) { const t = e.parentSchema.properties, { definedProperties: s } = e.it; for (const e of r) if (void 0 === (null == t ? void 0 : t[e]) && !s.has(e)) { const t = `required property "${e}" is not defined at "${u.schemaEnv.baseId + u.errSchemaPath}" (strictRequired)`; (0, a.checkStrictMode)(u, t, u.opts.strictRequired) } } function h() { t.forOf("prop", o, r => { e.setParams({ missingProperty: r }), t.if((0, s.noPropertyInData)(t, i, r, l.ownProperties), () => e.error()) }) } } }; t.default = o }, 4018: (e, t) => { function r(e, t) { return { validate: e, compare: t } } Object.defineProperty(t, "__esModule", { value: !0 }), t.formatNames = t.fastFormats = t.fullFormats = void 0, t.fullFormats = { date: r(a, o), time: r(c, u), "date-time": r(function (e) { const t = e.split(l); return 2 === t.length && a(t[0]) && c(t[1], !0) }, d), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: function (e) { return h.test(e) && m.test(e) }, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: function (e) { if (v.test(e)) return !1; try { return new RegExp(e), !0 } catch (e) { return !1 } }, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: function (e) { return f.lastIndex = 0, f.test(e) }, int32: { type: "number", validate: function (e) { return Number.isInteger(e) && e <= y && e >= p } }, int64: { type: "number", validate: function (e) { return Number.isInteger(e) } }, float: { type: "number", validate: g }, double: { type: "number", validate: g }, password: !0, binary: !0 }, t.fastFormats = { ...t.fullFormats, date: r(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, o), time: r(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, u), "date-time": r(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, d), uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i }, t.formatNames = Object.keys(t.fullFormats); const s = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, n = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function a(e) { const t = s.exec(e); if (!t) return !1; const r = +t[1], a = +t[2], o = +t[3]; return a >= 1 && a <= 12 && o >= 1 && o <= (2 === a && function (e) { return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0) }(r) ? 29 : n[a]) } function o(e, t) { if (e && t) return e > t ? 1 : e < t ? -1 : 0 } const i = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i; function c(e, t) { const r = i.exec(e); if (!r) return !1; const s = +r[1], n = +r[2], a = +r[3], o = r[5]; return (s <= 23 && n <= 59 && a <= 59 || 23 === s && 59 === n && 60 === a) && (!t || "" !== o) } function u(e, t) { if (!e || !t) return; const r = i.exec(e), s = i.exec(t); return r && s ? (e = r[1] + r[2] + r[3] + (r[4] || "")) > (t = s[1] + s[2] + s[3] + (s[4] || "")) ? 1 : e < t ? -1 : 0 : void 0 } const l = /t|\s/i; function d(e, t) { if (!e || !t) return; const [r, s] = e.split(l), [n, a] = t.split(l), i = o(r, n); return void 0 !== i ? i || u(s, a) : void 0 } const h = /\/|:/, m = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i; const f = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm; const p = -(2 ** 31), y = 2 ** 31 - 1; function g() { return !0 } const v = /[^\\]\\Z/ }, 4042: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0; var s = r(2586); Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function () { return s.KeywordCxt } }); var n = r(9029); Object.defineProperty(t, "_", { enumerable: !0, get: function () { return n._ } }), Object.defineProperty(t, "str", { enumerable: !0, get: function () { return n.str } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function () { return n.stringify } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function () { return n.nil } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function () { return n.Name } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function () { return n.CodeGen } }); const a = r(3558), o = r(4551), i = r(396), c = r(3835), u = r(9029), l = r(6939), d = r(208), h = r(4227), m = r(3837), f = r(5944), p = (e, t) => new RegExp(e, t); p.code = "new RegExp"; const y = ["removeAdditional", "useDefaults", "coerceTypes"], g = new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]), v = { errorDataPath: "", format: "`validateFormats: false` can be used instead.", nullable: '"nullable" keyword is supported by default.', jsonPointers: "Deprecated jsPropertySyntax can be used instead.", extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.", missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.", processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`", sourceCode: "Use option `code: {source: true}`", strictDefaults: "It is default now, see option `strict`.", strictKeywords: "It is default now, see option `strict`.", uniqueItems: '"uniqueItems" keyword is always validated.', unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).", cache: "Map is used as cache, schema object as key.", serialize: "Map is used as cache, schema object as key.", ajvErrors: "It is default now." }, $ = { ignoreKeywordsWithRef: "", jsPropertySyntax: "", unicode: '"minLength"/"maxLength" account for unicode characters by default.' }; function w(e) { var t, r, s, n, a, o, i, c, u, l, d, h, m, y, g, v, $, w, b, _, k, S, N, O, E; const P = e.strict, j = null === (t = e.code) || void 0 === t ? void 0 : t.optimize, T = !0 === j || void 0 === j ? 1 : j || 0, x = null !== (s = null === (r = e.code) || void 0 === r ? void 0 : r.regExp) && void 0 !== s ? s : p, I = null !== (n = e.uriResolver) && void 0 !== n ? n : f.default; return { strictSchema: null === (o = null !== (a = e.strictSchema) && void 0 !== a ? a : P) || void 0 === o || o, strictNumbers: null === (c = null !== (i = e.strictNumbers) && void 0 !== i ? i : P) || void 0 === c || c, strictTypes: null !== (l = null !== (u = e.strictTypes) && void 0 !== u ? u : P) && void 0 !== l ? l : "log", strictTuples: null !== (h = null !== (d = e.strictTuples) && void 0 !== d ? d : P) && void 0 !== h ? h : "log", strictRequired: null !== (y = null !== (m = e.strictRequired) && void 0 !== m ? m : P) && void 0 !== y && y, code: e.code ? { ...e.code, optimize: T, regExp: x } : { optimize: T, regExp: x }, loopRequired: null !== (g = e.loopRequired) && void 0 !== g ? g : 200, loopEnum: null !== (v = e.loopEnum) && void 0 !== v ? v : 200, meta: null === ($ = e.meta) || void 0 === $ || $, messages: null === (w = e.messages) || void 0 === w || w, inlineRefs: null === (b = e.inlineRefs) || void 0 === b || b, schemaId: null !== (_ = e.schemaId) && void 0 !== _ ? _ : "$id", addUsedSchema: null === (k = e.addUsedSchema) || void 0 === k || k, validateSchema: null === (S = e.validateSchema) || void 0 === S || S, validateFormats: null === (N = e.validateFormats) || void 0 === N || N, unicodeRegExp: null === (O = e.unicodeRegExp) || void 0 === O || O, int32range: null === (E = e.int32range) || void 0 === E || E, uriResolver: I } } class b { constructor(e = {}) { this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = new Set, this._loading = {}, this._cache = new Map, e = this.opts = { ...e, ...w(e) }; const { es5: t, lines: r } = this.opts.code; this.scope = new u.ValueScope({ scope: {}, prefixes: g, es5: t, lines: r }), this.logger = function (e) { if (!1 === e) return P; if (void 0 === e) return console; if (e.log && e.warn && e.error) return e; throw new Error("logger must implement log, warn and error methods") }(e.logger); const s = e.validateFormats; e.validateFormats = !1, this.RULES = (0, i.getRules)(), _.call(this, v, e, "NOT SUPPORTED"), _.call(this, $, e, "DEPRECATED", "warn"), this._metaOpts = E.call(this), e.formats && N.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), e.keywords && O.call(this, e.keywords), "object" == typeof e.meta && this.addMetaSchema(e.meta), S.call(this), e.validateFormats = s } _addVocabularies() { this.addKeyword("$async") } _addDefaultMetaSchema() { const { $data: e, meta: t, schemaId: r } = this.opts; let s = m; "id" === r && (s = { ...m }, s.id = s.$id, delete s.$id), t && e && this.addMetaSchema(s, s[r], !1) } defaultMeta() { const { meta: e, schemaId: t } = this.opts; return this.opts.defaultMeta = "object" == typeof e ? e[t] || e : void 0 } validate(e, t) { let r; if ("string" == typeof e) { if (r = this.getSchema(e), !r) throw new Error(`no schema with key or ref "${e}"`) } else r = this.compile(e); const s = r(t); return "$async" in r || (this.errors = r.errors), s } compile(e, t) { const r = this._addSchema(e, t); return r.validate || this._compileSchemaEnv(r) } compileAsync(e, t) { if ("function" != typeof this.opts.loadSchema) throw new Error("options.loadSchema should be a function"); const { loadSchema: r } = this.opts; return s.call(this, e, t); async function s(e, t) { await n.call(this, e.$schema); const r = this._addSchema(e, t); return r.validate || a.call(this, r) } async function n(e) { e && !this.getSchema(e) && await s.call(this, { $ref: e }, !0) } async function a(e) { try { return this._compileSchemaEnv(e) } catch (t) { if (!(t instanceof o.default)) throw t; return i.call(this, t), await c.call(this, t.missingSchema), a.call(this, e) } } function i({ missingSchema: e, missingRef: t }) { if (this.refs[e]) throw new Error(`AnySchema ${e} is loaded but ${t} cannot be resolved`) } async function c(e) { const r = await u.call(this, e); this.refs[e] || await n.call(this, r.$schema), this.refs[e] || this.addSchema(r, e, t) } async function u(e) { const t = this._loading[e]; if (t) return t; try { return await (this._loading[e] = r(e)) } finally { delete this._loading[e] } } } addSchema(e, t, r, s = this.opts.validateSchema) { if (Array.isArray(e)) { for (const t of e) this.addSchema(t, void 0, r, s); return this } let n; if ("object" == typeof e) { const { schemaId: t } = this.opts; if (n = e[t], void 0 !== n && "string" != typeof n) throw new Error(`schema ${t} must be string`) } return t = (0, l.normalizeId)(t || n), this._checkUnique(t), this.schemas[t] = this._addSchema(e, r, t, s, !0), this } addMetaSchema(e, t, r = this.opts.validateSchema) { return this.addSchema(e, t, !0, r), this } validateSchema(e, t) { if ("boolean" == typeof e) return !0; let r; if (r = e.$schema, void 0 !== r && "string" != typeof r) throw new Error("$schema must be a string"); if (r = r || this.opts.defaultMeta || this.defaultMeta(), !r) return this.logger.warn("meta-schema not available"), this.errors = null, !0; const s = this.validate(r, e); if (!s && t) { const e = "schema is invalid: " + this.errorsText(); if ("log" !== this.opts.validateSchema) throw new Error(e); this.logger.error(e) } return s } getSchema(e) { let t; for (; "string" == typeof (t = k.call(this, e));)e = t; if (void 0 === t) { const { schemaId: r } = this.opts, s = new c.SchemaEnv({ schema: {}, schemaId: r }); if (t = c.resolveSchema.call(this, s, e), !t) return; this.refs[e] = t } return t.validate || this._compileSchemaEnv(t) } removeSchema(e) { if (e instanceof RegExp) return this._removeAllSchemas(this.schemas, e), this._removeAllSchemas(this.refs, e), this; switch (typeof e) { case "undefined": return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this; case "string": { const t = k.call(this, e); return "object" == typeof t && this._cache.delete(t.schema), delete this.schemas[e], delete this.refs[e], this } case "object": { const t = e; this._cache.delete(t); let r = e[this.opts.schemaId]; return r && (r = (0, l.normalizeId)(r), delete this.schemas[r], delete this.refs[r]), this } default: throw new Error("ajv.removeSchema: invalid parameter") } } addVocabulary(e) { for (const t of e) this.addKeyword(t); return this } addKeyword(e, t) { let r; if ("string" == typeof e) r = e, "object" == typeof t && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), t.keyword = r); else { if ("object" != typeof e || void 0 !== t) throw new Error("invalid addKeywords parameters"); if (r = (t = e).keyword, Array.isArray(r) && !r.length) throw new Error("addKeywords: keyword must be string or non-empty array") } if (T.call(this, r, t), !t) return (0, h.eachItem)(r, e => x.call(this, e)), this; M.call(this, t); const s = { ...t, type: (0, d.getJSONTypes)(t.type), schemaType: (0, d.getJSONTypes)(t.schemaType) }; return (0, h.eachItem)(r, 0 === s.type.length ? e => x.call(this, e, s) : e => s.type.forEach(t => x.call(this, e, s, t))), this } getKeyword(e) { const t = this.RULES.all[e]; return "object" == typeof t ? t.definition : !!t } removeKeyword(e) { const { RULES: t } = this; delete t.keywords[e], delete t.all[e]; for (const r of t.rules) { const t = r.rules.findIndex(t => t.keyword === e); t >= 0 && r.rules.splice(t, 1) } return this } addFormat(e, t) { return "string" == typeof t && (t = new RegExp(t)), this.formats[e] = t, this } errorsText(e = this.errors, { separator: t = ", ", dataVar: r = "data" } = {}) { return e && 0 !== e.length ? e.map(e => `${r}${e.instancePath} ${e.message}`).reduce((e, r) => e + t + r) : "No errors" } $dataMetaSchema(e, t) { const r = this.RULES.all; e = JSON.parse(JSON.stringify(e)); for (const s of t) { const t = s.split("/").slice(1); let n = e; for (const e of t) n = n[e]; for (const e in r) { const t = r[e]; if ("object" != typeof t) continue; const { $data: s } = t.definition, a = n[e]; s && a && (n[e] = D(a)) } } return e } _removeAllSchemas(e, t) { for (const r in e) { const s = e[r]; t && !t.test(r) || ("string" == typeof s ? delete e[r] : s && !s.meta && (this._cache.delete(s.schema), delete e[r])) } } _addSchema(e, t, r, s = this.opts.validateSchema, n = this.opts.addUsedSchema) { let a; const { schemaId: o } = this.opts; if ("object" == typeof e) a = e[o]; else { if (this.opts.jtd) throw new Error("schema must be object"); if ("boolean" != typeof e) throw new Error("schema must be object or boolean") } let i = this._cache.get(e); if (void 0 !== i) return i; r = (0, l.normalizeId)(a || r); const u = l.getSchemaRefs.call(this, e, r); return i = new c.SchemaEnv({ schema: e, schemaId: o, meta: t, baseId: r, localRefs: u }), this._cache.set(i.schema, i), n && !r.startsWith("#") && (r && this._checkUnique(r), this.refs[r] = i), s && this.validateSchema(e, !0), i } _checkUnique(e) { if (this.schemas[e] || this.refs[e]) throw new Error(`schema with key or id "${e}" already exists`) } _compileSchemaEnv(e) { if (e.meta ? this._compileMetaSchema(e) : c.compileSchema.call(this, e), !e.validate) throw new Error("ajv implementation error"); return e.validate } _compileMetaSchema(e) { const t = this.opts; this.opts = this._metaOpts; try { c.compileSchema.call(this, e) } finally { this.opts = t } } } function _(e, t, r, s = "error") { for (const n in e) { const a = n; a in t && this.logger[s](`${r}: option ${n}. ${e[a]}`) } } function k(e) { return e = (0, l.normalizeId)(e), this.schemas[e] || this.refs[e] } function S() { const e = this.opts.schemas; if (e) if (Array.isArray(e)) this.addSchema(e); else for (const t in e) this.addSchema(e[t], t) } function N() { for (const e in this.opts.formats) { const t = this.opts.formats[e]; t && this.addFormat(e, t) } } function O(e) { if (Array.isArray(e)) this.addVocabulary(e); else { this.logger.warn("keywords option as map is deprecated, pass array"); for (const t in e) { const r = e[t]; r.keyword || (r.keyword = t), this.addKeyword(r) } } } function E() { const e = { ...this.opts }; for (const t of y) delete e[t]; return e } b.ValidationError = a.default, b.MissingRefError = o.default, t.default = b; const P = { log() { }, warn() { }, error() { } }; const j = /^[a-z_$][a-z0-9_$:-]*$/i; function T(e, t) { const { RULES: r } = this; if ((0, h.eachItem)(e, e => { if (r.keywords[e]) throw new Error(`Keyword ${e} is already defined`); if (!j.test(e)) throw new Error(`Keyword ${e} has invalid name`) }), t && t.$data && !("code" in t) && !("validate" in t)) throw new Error('$data keyword must have "code" or "validate" function') } function x(e, t, r) { var s; const n = null == t ? void 0 : t.post; if (r && n) throw new Error('keyword with "post" flag cannot have "type"'); const { RULES: a } = this; let o = n ? a.post : a.rules.find(({ type: e }) => e === r); if (o || (o = { type: r, rules: [] }, a.rules.push(o)), a.keywords[e] = !0, !t) return; const i = { keyword: e, definition: { ...t, type: (0, d.getJSONTypes)(t.type), schemaType: (0, d.getJSONTypes)(t.schemaType) } }; t.before ? I.call(this, o, i, t.before) : o.rules.push(i), a.all[e] = i, null === (s = t.implements) || void 0 === s || s.forEach(e => this.addKeyword(e)) } function I(e, t, r) { const s = e.rules.findIndex(e => e.keyword === r); s >= 0 ? e.rules.splice(s, 0, t) : (e.rules.push(t), this.logger.warn(`rule ${r} is not defined`)) } function M(e) { let { metaSchema: t } = e; void 0 !== t && (e.$data && this.opts.$data && (t = D(t)), e.validateSchema = this.compile(t, !0)) } const C = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }; function D(e) { return { anyOf: [e, C] } } }, 4227: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.checkStrictMode = t.getErrorPath = t.Type = t.useFunc = t.setEvaluated = t.evaluatedPropsToName = t.mergeEvaluated = t.eachItem = t.unescapeJsonPointer = t.escapeJsonPointer = t.escapeFragment = t.unescapeFragment = t.schemaRefOrVal = t.schemaHasRulesButRef = t.schemaHasRules = t.checkUnknownRules = t.alwaysValidSchema = t.toHash = void 0; const s = r(9029), n = r(1520); function a(e, t = e.schema) { const { opts: r, self: s } = e; if (!r.strictSchema) return; if ("boolean" == typeof t) return; const n = s.RULES.keywords; for (const r in t) n[r] || f(e, `unknown keyword: "${r}"`) } function o(e, t) { if ("boolean" == typeof e) return !e; for (const r in e) if (t[r]) return !0; return !1 } function i(e) { return "number" == typeof e ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1") } function c(e) { return e.replace(/~1/g, "/").replace(/~0/g, "~") } function u({ mergeNames: e, mergeToName: t, mergeValues: r, resultToName: n }) { return (a, o, i, c) => { const u = void 0 === i ? o : i instanceof s.Name ? (o instanceof s.Name ? e(a, o, i) : t(a, o, i), i) : o instanceof s.Name ? (t(a, i, o), o) : r(o, i); return c !== s.Name || u instanceof s.Name ? u : n(a, u) } } function l(e, t) { if (!0 === t) return e.var("props", !0); const r = e.var("props", s._`{}`); return void 0 !== t && d(e, r, t), r } function d(e, t, r) { Object.keys(r).forEach(r => e.assign(s._`${t}${(0, s.getProperty)(r)}`, !0)) } t.toHash = function (e) { const t = {}; for (const r of e) t[r] = !0; return t }, t.alwaysValidSchema = function (e, t) { return "boolean" == typeof t ? t : 0 === Object.keys(t).length || (a(e, t), !o(t, e.self.RULES.all)) }, t.checkUnknownRules = a, t.schemaHasRules = o, t.schemaHasRulesButRef = function (e, t) { if ("boolean" == typeof e) return !e; for (const r in e) if ("$ref" !== r && t.all[r]) return !0; return !1 }, t.schemaRefOrVal = function ({ topSchemaRef: e, schemaPath: t }, r, n, a) { if (!a) { if ("number" == typeof r || "boolean" == typeof r) return r; if ("string" == typeof r) return s._`${r}` } return s._`${e}${t}${(0, s.getProperty)(n)}` }, t.unescapeFragment = function (e) { return c(decodeURIComponent(e)) }, t.escapeFragment = function (e) { return encodeURIComponent(i(e)) }, t.escapeJsonPointer = i, t.unescapeJsonPointer = c, t.eachItem = function (e, t) { if (Array.isArray(e)) for (const r of e) t(r); else t(e) }, t.mergeEvaluated = { props: u({ mergeNames: (e, t, r) => e.if(s._`${r} !== true && ${t} !== undefined`, () => { e.if(s._`${t} === true`, () => e.assign(r, !0), () => e.assign(r, s._`${r} || {}`).code(s._`Object.assign(${r}, ${t})`)) }), mergeToName: (e, t, r) => e.if(s._`${r} !== true`, () => { !0 === t ? e.assign(r, !0) : (e.assign(r, s._`${r} || {}`), d(e, r, t)) }), mergeValues: (e, t) => !0 === e || { ...e, ...t }, resultToName: l }), items: u({ mergeNames: (e, t, r) => e.if(s._`${r} !== true && ${t} !== undefined`, () => e.assign(r, s._`${t} === true ? true : ${r} > ${t} ? ${r} : ${t}`)), mergeToName: (e, t, r) => e.if(s._`${r} !== true`, () => e.assign(r, !0 === t || s._`${r} > ${t} ? ${r} : ${t}`)), mergeValues: (e, t) => !0 === e || Math.max(e, t), resultToName: (e, t) => e.var("items", t) }) }, t.evaluatedPropsToName = l, t.setEvaluated = d; const h = {}; var m; function f(e, t, r = e.opts.strictSchema) { if (r) { if (t = `strict mode: ${t}`, !0 === r) throw new Error(t); e.self.logger.warn(t) } } t.useFunc = function (e, t) { return e.scopeValue("func", { ref: t, code: h[t.code] || (h[t.code] = new n._Code(t.code)) }) }, function (e) { e[e.Num = 0] = "Num", e[e.Str = 1] = "Str" }(m || (t.Type = m = {})), t.getErrorPath = function (e, t, r) { if (e instanceof s.Name) { const n = t === m.Num; return r ? n ? s._`"[" + ${e} + "]"` : s._`"['" + ${e} + "']"` : n ? s._`"/" + ${e}` : s._`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")` } return r ? (0, s.getProperty)(e).toString() : "/" + i(e) }, t.checkStrictMode = f }, 4426: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(4227), n = { keyword: ["then", "else"], schemaType: ["object", "boolean"], code({ keyword: e, parentSchema: t, it: r }) { void 0 === t.if && (0, s.checkStrictMode)(r, `"${e}" without "if" is ignored`) } }; t.default = n }, 4486: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = { keyword: ["maxProperties", "minProperties"], type: "object", schemaType: "number", $data: !0, error: { message({ keyword: e, schemaCode: t }) { const r = "maxProperties" === e ? "more" : "fewer"; return s.str`must NOT have ${r} than ${t} properties` }, params: ({ schemaCode: e }) => s._`{limit: ${e}}` }, code(e) { const { keyword: t, data: r, schemaCode: n } = e, a = "maxProperties" === t ? s.operators.GT : s.operators.LT; e.fail$data(s._`Object.keys(${r}).length ${a} ${n}`) } }; t.default = n }, 4495: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.extendSubschemaMode = t.extendSubschemaData = t.getSubschema = void 0; const s = r(9029), n = r(4227); t.getSubschema = function (e, { keyword: t, schemaProp: r, schema: a, schemaPath: o, errSchemaPath: i, topSchemaRef: c }) { if (void 0 !== t && void 0 !== a) throw new Error('both "keyword" and "schema" passed, only one allowed'); if (void 0 !== t) { const a = e.schema[t]; return void 0 === r ? { schema: a, schemaPath: s._`${e.schemaPath}${(0, s.getProperty)(t)}`, errSchemaPath: `${e.errSchemaPath}/${t}` } : { schema: a[r], schemaPath: s._`${e.schemaPath}${(0, s.getProperty)(t)}${(0, s.getProperty)(r)}`, errSchemaPath: `${e.errSchemaPath}/${t}/${(0, n.escapeFragment)(r)}` } } if (void 0 !== a) { if (void 0 === o || void 0 === i || void 0 === c) throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'); return { schema: a, schemaPath: o, topSchemaRef: c, errSchemaPath: i } } throw new Error('either "keyword" or "schema" must be passed') }, t.extendSubschemaData = function (e, t, { dataProp: r, dataPropType: a, data: o, dataTypes: i, propertyName: c }) { if (void 0 !== o && void 0 !== r) throw new Error('both "data" and "dataProp" passed, only one allowed'); const { gen: u } = t; if (void 0 !== r) { const { errorPath: o, dataPathArr: i, opts: c } = t; l(u.let("data", s._`${t.data}${(0, s.getProperty)(r)}`, !0)), e.errorPath = s.str`${o}${(0, n.getErrorPath)(r, a, c.jsPropertySyntax)}`, e.parentDataProperty = s._`${r}`, e.dataPathArr = [...i, e.parentDataProperty] } if (void 0 !== o) { l(o instanceof s.Name ? o : u.let("data", o, !0)), void 0 !== c && (e.propertyName = c) } function l(r) { e.data = r, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = new Set, e.parentData = t.data, e.dataNames = [...t.dataNames, r] } i && (e.dataTypes = i) }, t.extendSubschemaMode = function (e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: s, createErrors: n, allErrors: a }) { void 0 !== s && (e.compositeRule = s), void 0 !== n && (e.createErrors = n), void 0 !== a && (e.allErrors = a), e.jtdDiscriminator = t, e.jtdMetadata = r } }, 4541: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv2019 = void 0; const s = r(4042), n = r(6144), a = r(5520), o = r(5413), i = r(3265), c = r(6653), u = r(1024), l = "https://json-schema.org/draft/2019-09/schema"; class d extends s.default { constructor(e = {}) { super({ ...e, dynamicRef: !0, next: !0, unevaluated: !0 }) } _addVocabularies() { super._addVocabularies(), this.addVocabulary(a.default), n.default.forEach(e => this.addVocabulary(e)), this.addVocabulary(o.default), this.addVocabulary(i.default), this.opts.discriminator && this.addKeyword(c.default) } _addDefaultMetaSchema() { super._addDefaultMetaSchema(); const { $data: e, meta: t } = this.opts; t && (u.default.call(this, e), this.refs["http://json-schema.org/schema"] = l) } defaultMeta() { return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(l) ? l : void 0) } } t.Ajv2019 = d, e.exports = t = d, e.exports.Ajv2019 = d, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = d; var h = r(2586); Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function () { return h.KeywordCxt } }); var m = r(9029); Object.defineProperty(t, "_", { enumerable: !0, get: function () { return m._ } }), Object.defineProperty(t, "str", { enumerable: !0, get: function () { return m.str } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function () { return m.stringify } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function () { return m.nil } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function () { return m.Name } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function () { return m.CodeGen } }); var f = r(3558); Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function () { return f.default } }); var p = r(4551); Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function () { return p.default } }) }, 4551: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(6939); class n extends Error { constructor(e, t, r, n) { super(n || `can't resolve reference ${r} from id ${t}`), this.missingRef = (0, s.resolveUrl)(e, t, r), this.missingSchema = (0, s.normalizeId)((0, s.getFullPath)(e, this.missingRef)) } } t.default = n }, 4737: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = { keyword: "format", type: ["number", "string"], schemaType: "string", $data: !0, error: { message: ({ schemaCode: e }) => s.str`must match format "${e}"`, params: ({ schemaCode: e }) => s._`{format: ${e}}` }, code(e, t) { const { gen: r, data: n, $data: a, schema: o, schemaCode: i, it: c } = e, { opts: u, errSchemaPath: l, schemaEnv: d, self: h } = c; u.validateFormats && (a ? function () { const a = r.scopeValue("formats", { ref: h.formats, code: u.code.formats }), o = r.const("fDef", s._`${a}[${i}]`), c = r.let("fType"), l = r.let("format"); r.if(s._`typeof ${o} == "object" && !(${o} instanceof RegExp)`, () => r.assign(c, s._`${o}.type || "string"`).assign(l, s._`${o}.validate`), () => r.assign(c, s._`"string"`).assign(l, o)), e.fail$data((0, s.or)(!1 === u.strictSchema ? s.nil : s._`${i} && !${l}`, function () { const e = d.$async ? s._`(${o}.async ? await ${l}(${n}) : ${l}(${n}))` : s._`${l}(${n})`, r = s._`(typeof ${l} == "function" ? ${e} : ${l}.test(${n}))`; return s._`${l} && ${l} !== true && ${c} === ${t} && !${r}` }())) }() : function () { const a = h.formats[o]; if (!a) return void function () { if (!1 === u.strictSchema) return void h.logger.warn(e()); throw new Error(e()); function e() { return `unknown format "${o}" ignored in schema at path "${l}"` } }(); if (!0 === a) return; const [i, c, m] = function (e) { const t = e instanceof RegExp ? (0, s.regexpCode)(e) : u.code.formats ? s._`${u.code.formats}${(0, s.getProperty)(o)}` : void 0, n = r.scopeValue("formats", { key: o, ref: e, code: t }); if ("object" == typeof e && !(e instanceof RegExp)) return [e.type || "string", e.validate, s._`${n}.validate`]; return ["string", e, n] }(a); i === t && e.pass(function () { if ("object" == typeof a && !(a instanceof RegExp) && a.async) { if (!d.$async) throw new Error("async format in sync schema"); return s._`await ${m}(${n})` } return "function" == typeof c ? s._`${m}(${n})` : s._`${m}.test(${n})` }()) }()) } }; t.default = n }, 4834: (e, t, r) => { const { HEX: s } = r(4914), n = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u; function a(e) { if (u(e, ".") < 3) return { host: e, isIPV4: !1 }; const t = e.match(n) || [], [r] = t; return r ? { host: c(r, "."), isIPV4: !0 } : { host: e, isIPV4: !1 } } function o(e, t = !1) { let r = "", n = !0; for (const t of e) { if (void 0 === s[t]) return; "0" !== t && !0 === n && (n = !1), n || (r += t) } return t && 0 === r.length && (r = "0"), r } function i(e) { if (u(e, ":") < 2) return { host: e, isIPV6: !1 }; const t = function (e) { let t = 0; const r = { error: !1, address: "", zone: "" }, s = [], n = []; let a = !1, i = !1, c = !1; function u() { if (n.length) { if (!1 === a) { const e = o(n); if (void 0 === e) return r.error = !0, !1; s.push(e) } n.length = 0 } return !0 } for (let o = 0; o < e.length; o++) { const l = e[o]; if ("[" !== l && "]" !== l) if (":" !== l) if ("%" === l) { if (!u()) break; a = !0 } else n.push(l); else { if (!0 === i && (c = !0), !u()) break; if (t++, s.push(":"), t > 7) { r.error = !0; break } o - 1 >= 0 && ":" === e[o - 1] && (i = !0) } } return n.length && (a ? r.zone = n.join("") : c ? s.push(n.join("")) : s.push(o(n))), r.address = s.join(""), r }(e); if (t.error) return { host: e, isIPV6: !1 }; { let e = t.address, r = t.address; return t.zone && (e += "%" + t.zone, r += "%25" + t.zone), { host: e, escapedHost: r, isIPV6: !0 } } } function c(e, t) { let r = "", s = !0; const n = e.length; for (let a = 0; a < n; a++) { const o = e[a]; "0" === o && s ? (a + 1 <= n && e[a + 1] === t || a + 1 === n) && (r += o, s = !1) : (s = o === t, r += o) } return r } function u(e, t) { let r = 0; for (let s = 0; s < e.length; s++)e[s] === t && r++; return r } const l = /^\.\.?\//u, d = /^\/\.(?:\/|$)/u, h = /^\/\.\.(?:\/|$)/u, m = /^\/?(?:.|\n)*?(?=\/|$)/u; e.exports = { recomposeAuthority: function (e) { const t = []; if (void 0 !== e.userinfo && (t.push(e.userinfo), t.push("@")), void 0 !== e.host) { let r = unescape(e.host); const s = a(r); if (s.isIPV4) r = s.host; else { const t = i(s.host); r = !0 === t.isIPV6 ? `[${t.escapedHost}]` : e.host } t.push(r) } return "number" != typeof e.port && "string" != typeof e.port || (t.push(":"), t.push(String(e.port))), t.length ? t.join("") : void 0 }, normalizeComponentEncoding: function (e, t) { const r = !0 !== t ? escape : unescape; return void 0 !== e.scheme && (e.scheme = r(e.scheme)), void 0 !== e.userinfo && (e.userinfo = r(e.userinfo)), void 0 !== e.host && (e.host = r(e.host)), void 0 !== e.path && (e.path = r(e.path)), void 0 !== e.query && (e.query = r(e.query)), void 0 !== e.fragment && (e.fragment = r(e.fragment)), e }, removeDotSegments: function (e) { const t = []; for (; e.length;)if (e.match(l)) e = e.replace(l, ""); else if (e.match(d)) e = e.replace(d, "/"); else if (e.match(h)) e = e.replace(h, "/"), t.pop(); else if ("." === e || ".." === e) e = ""; else { const r = e.match(m); if (!r) throw new Error("Unexpected dot segment condition"); { const s = r[0]; e = e.slice(s.length), t.push(s) } } return t.join("") }, normalizeIPv4: a, normalizeIPv6: i, stringArrayToHexStripped: o } }, 4845: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(3025), n = { keyword: "dependentSchemas", type: "object", schemaType: "object", code: e => (0, s.validateSchemaDeps)(e) }; t.default = n }, 4908: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/meta/applicator","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/applicator":true},"$recursiveAnchor":true,"title":"Applicator vocabulary meta-schema","type":["object","boolean"],"properties":{"additionalItems":{"$recursiveRef":"#"},"unevaluatedItems":{"$recursiveRef":"#"},"items":{"anyOf":[{"$recursiveRef":"#"},{"$ref":"#/$defs/schemaArray"}]},"contains":{"$recursiveRef":"#"},"additionalProperties":{"$recursiveRef":"#"},"unevaluatedProperties":{"$recursiveRef":"#"},"properties":{"type":"object","additionalProperties":{"$recursiveRef":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$recursiveRef":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependentSchemas":{"type":"object","additionalProperties":{"$recursiveRef":"#"}},"propertyNames":{"$recursiveRef":"#"},"if":{"$recursiveRef":"#"},"then":{"$recursiveRef":"#"},"else":{"$recursiveRef":"#"},"allOf":{"$ref":"#/$defs/schemaArray"},"anyOf":{"$ref":"#/$defs/schemaArray"},"oneOf":{"$ref":"#/$defs/schemaArray"},"not":{"$recursiveRef":"#"}},"$defs":{"schemaArray":{"type":"array","minItems":1,"items":{"$recursiveRef":"#"}}}}') }, 4914: e => { e.exports = { HEX: { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 } } }, 5333: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(5765), n = r(9029), a = r(4227), o = r(4227), i = { keyword: "patternProperties", type: "object", schemaType: "object", code(e) { const { gen: t, schema: r, data: i, parentSchema: c, it: u } = e, { opts: l } = u, d = (0, s.allSchemaProperties)(r), h = d.filter(e => (0, a.alwaysValidSchema)(u, r[e])); if (0 === d.length || h.length === d.length && (!u.opts.unevaluated || !0 === u.props)) return; const m = l.strictSchema && !l.allowMatchingProperties && c.properties, f = t.name("valid"); !0 === u.props || u.props instanceof n.Name || (u.props = (0, o.evaluatedPropsToName)(t, u.props)); const { props: p } = u; function y(e) { for (const t in m) new RegExp(e).test(t) && (0, a.checkStrictMode)(u, `property ${t} matches pattern ${e} (use allowMatchingProperties)`) } function g(r) { t.forIn("key", i, a => { t.if(n._`${(0, s.usePattern)(e, r)}.test(${a})`, () => { const s = h.includes(r); s || e.subschema({ keyword: "patternProperties", schemaProp: r, dataProp: a, dataPropType: o.Type.Str }, f), u.opts.unevaluated && !0 !== p ? t.assign(n._`${p}[${a}]`, !0) : s || u.allErrors || t.if((0, n.not)(f), () => t.break()) }) }) } !function () { for (const e of d) m && y(e), u.allErrors ? g(e) : (t.var(f, !0), g(e), t.if(f)) }() } }; t.default = i }, 5354: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(494), n = { keyword: "prefixItems", type: "array", schemaType: ["array"], before: "uniqueItems", code: e => (0, s.validateTuple)(e, "items") }; t.default = n }, 5413: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(1846), n = r(4845), a = r(2626), o = [s.default, n.default, a.default]; t.default = o }, 5457: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.validateAdditionalItems = void 0; const s = r(9029), n = r(4227), a = { keyword: "additionalItems", type: "array", schemaType: ["boolean", "object"], before: "uniqueItems", error: { message: ({ params: { len: e } }) => s.str`must NOT have more than ${e} items`, params: ({ params: { len: e } }) => s._`{limit: ${e}}` }, code(e) { const { parentSchema: t, it: r } = e, { items: s } = t; Array.isArray(s) ? o(e, s) : (0, n.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas') } }; function o(e, t) { const { gen: r, schema: a, data: o, keyword: i, it: c } = e; c.items = !0; const u = r.const("len", s._`${o}.length`); if (!1 === a) e.setParams({ len: t.length }), e.pass(s._`${u} <= ${t.length}`); else if ("object" == typeof a && !(0, n.alwaysValidSchema)(c, a)) { const a = r.var("valid", s._`${u} <= ${t.length}`); r.if((0, s.not)(a), () => function (a) { r.forRange("i", t.length, u, t => { e.subschema({ keyword: i, dataProp: t, dataPropType: n.Type.Num }, a), c.allErrors || r.if((0, s.not)(a), () => r.break()) }) }(a)), e.ok(a) } } t.validateAdditionalItems = o, t.default = a }, 5520: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(2476), n = r(3252), a = r(2721), o = r(3799), i = [s.default, n.default, a.default, o.default]; t.default = i }, 5765: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.validateUnion = t.validateArray = t.usePattern = t.callValidateCode = t.schemaProperties = t.allSchemaProperties = t.noPropertyInData = t.propertyInData = t.isOwnProperty = t.hasPropFunc = t.reportMissingProp = t.checkMissingProp = t.checkReportMissingProp = void 0; const s = r(9029), n = r(4227), a = r(2023), o = r(4227); function i(e) { return e.scopeValue("func", { ref: Object.prototype.hasOwnProperty, code: s._`Object.prototype.hasOwnProperty` }) } function c(e, t, r) { return s._`${i(e)}.call(${t}, ${r})` } function u(e, t, r, n) { const a = s._`${t}${(0, s.getProperty)(r)} === undefined`; return n ? (0, s.or)(a, (0, s.not)(c(e, t, r))) : a } function l(e) { return e ? Object.keys(e).filter(e => "__proto__" !== e) : [] } t.checkReportMissingProp = function (e, t) { const { gen: r, data: n, it: a } = e; r.if(u(r, n, t, a.opts.ownProperties), () => { e.setParams({ missingProperty: s._`${t}` }, !0), e.error() }) }, t.checkMissingProp = function ({ gen: e, data: t, it: { opts: r } }, n, a) { return (0, s.or)(...n.map(n => (0, s.and)(u(e, t, n, r.ownProperties), s._`${a} = ${n}`))) }, t.reportMissingProp = function (e, t) { e.setParams({ missingProperty: t }, !0), e.error() }, t.hasPropFunc = i, t.isOwnProperty = c, t.propertyInData = function (e, t, r, n) { const a = s._`${t}${(0, s.getProperty)(r)} !== undefined`; return n ? s._`${a} && ${c(e, t, r)}` : a }, t.noPropertyInData = u, t.allSchemaProperties = l, t.schemaProperties = function (e, t) { return l(t).filter(r => !(0, n.alwaysValidSchema)(e, t[r])) }, t.callValidateCode = function ({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: o, errorPath: i }, it: c }, u, l, d) { const h = d ? s._`${e}, ${t}, ${n}${o}` : t, m = [[a.default.instancePath, (0, s.strConcat)(a.default.instancePath, i)], [a.default.parentData, c.parentData], [a.default.parentDataProperty, c.parentDataProperty], [a.default.rootData, a.default.rootData]]; c.opts.dynamicRef && m.push([a.default.dynamicAnchors, a.default.dynamicAnchors]); const f = s._`${h}, ${r.object(...m)}`; return l !== s.nil ? s._`${u}.call(${l}, ${f})` : s._`${u}(${f})` }; const d = s._`new RegExp`; t.usePattern = function ({ gen: e, it: { opts: t } }, r) { const n = t.unicodeRegExp ? "u" : "", { regExp: a } = t.code, i = a(r, n); return e.scopeValue("pattern", { key: i.toString(), ref: i, code: s._`${"new RegExp" === a.code ? d : (0, o.useFunc)(e, a)}(${r}, ${n})` }) }, t.validateArray = function (e) { const { gen: t, data: r, keyword: a, it: o } = e, i = t.name("valid"); if (o.allErrors) { const e = t.let("valid", !0); return c(() => t.assign(e, !1)), e } return t.var(i, !0), c(() => t.break()), i; function c(o) { const c = t.const("len", s._`${r}.length`); t.forRange("i", 0, c, r => { e.subschema({ keyword: a, dataProp: r, dataPropType: n.Type.Num }, i), t.if((0, s.not)(i), o) }) } }, t.validateUnion = function (e) { const { gen: t, schema: r, keyword: a, it: o } = e; if (!Array.isArray(r)) throw new Error("ajv implementation error"); if (r.some(e => (0, n.alwaysValidSchema)(o, e)) && !o.opts.unevaluated) return; const i = t.let("valid", !1), c = t.name("_valid"); t.block(() => r.forEach((r, n) => { const o = e.subschema({ keyword: a, schemaProp: n, compositeRule: !0 }, c); t.assign(i, s._`${i} || ${c}`); e.mergeValidEvaluated(o, c) || t.if((0, s.not)(i)) })), e.result(i, () => e.reset(), () => e.error(!0)) } }, 5844: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(4227), n = { keyword: "allOf", schemaType: "array", code(e) { const { gen: t, schema: r, it: n } = e; if (!Array.isArray(r)) throw new Error("ajv implementation error"); const a = t.name("valid"); r.forEach((t, r) => { if ((0, s.alwaysValidSchema)(n, t)) return; const o = e.subschema({ keyword: "allOf", schemaProp: r }, a); e.ok(a), e.mergeEvaluated(o) }) } }; t.default = n }, 5882: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = s.operators, a = { maximum: { okStr: "<=", ok: n.LTE, fail: n.GT }, minimum: { okStr: ">=", ok: n.GTE, fail: n.LT }, exclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE }, exclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE } }, o = { message: ({ keyword: e, schemaCode: t }) => s.str`must be ${a[e].okStr} ${t}`, params: ({ keyword: e, schemaCode: t }) => s._`{comparison: ${a[e].okStr}, limit: ${t}}` }, i = { keyword: Object.keys(a), type: "number", schemaType: "number", $data: !0, error: o, code(e) { const { keyword: t, data: r, schemaCode: n } = e; e.fail$data(s._`${r} ${a[t].fail} ${n} || isNaN(${r})`) } }; t.default = i }, 5944: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(8343); s.code = 'require("ajv/dist/runtime/uri").default', t.default = s }, 6144: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(2128), n = r(7060), a = r(6378), o = r(7532), i = r(9857), c = [s.default, n.default, (0, a.default)(), o.default, i.metadataVocabulary, i.contentVocabulary]; t.default = c }, 6163: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = { keyword: "oneOf", schemaType: "array", trackErrors: !0, error: { message: "must match exactly one schema in oneOf", params: ({ params: e }) => s._`{passingSchemas: ${e.passing}}` }, code(e) { const { gen: t, schema: r, parentSchema: a, it: o } = e; if (!Array.isArray(r)) throw new Error("ajv implementation error"); if (o.opts.discriminator && a.discriminator) return; const i = r, c = t.let("valid", !1), u = t.let("passing", null), l = t.name("_valid"); e.setParams({ passing: u }), t.block(function () { i.forEach((r, a) => { let i; (0, n.alwaysValidSchema)(o, r) ? t.var(l, !0) : i = e.subschema({ keyword: "oneOf", schemaProp: a, compositeRule: !0 }, l), a > 0 && t.if(s._`${l} && ${c}`).assign(c, !1).assign(u, s._`[${u}, ${a}]`).else(), t.if(l, () => { t.assign(c, !0), t.assign(u, a), i && e.mergeEvaluated(i, s.Name) }) }) }), e.result(c, () => e.reset(), () => e.error(!0)) } }; t.default = a }, 6250: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(2017); s.code = 'require("ajv/dist/runtime/equal").default', t.default = s }, 6378: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(5457), n = r(5354), a = r(494), o = r(3966), i = r(2661), c = r(3025), u = r(9713), l = r(8660), d = r(117), h = r(5333), m = r(7923), f = r(6505), p = r(6163), y = r(5844), g = r(1239), v = r(4426); t.default = function (e = !1) { const t = [m.default, f.default, p.default, y.default, g.default, v.default, u.default, l.default, c.default, d.default, h.default]; return e ? t.push(n.default, o.default) : t.push(s.default, a.default), t.push(i.default), t } }, 6461: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.formatLimitDefinition = void 0; const s = r(3282), n = r(9029), a = n.operators, o = { formatMaximum: { okStr: "<=", ok: a.LTE, fail: a.GT }, formatMinimum: { okStr: ">=", ok: a.GTE, fail: a.LT }, formatExclusiveMaximum: { okStr: "<", ok: a.LT, fail: a.GTE }, formatExclusiveMinimum: { okStr: ">", ok: a.GT, fail: a.LTE } }, i = { message: ({ keyword: e, schemaCode: t }) => n.str`should be ${o[e].okStr} ${t}`, params: ({ keyword: e, schemaCode: t }) => n._`{comparison: ${o[e].okStr}, limit: ${t}}` }; t.formatLimitDefinition = { keyword: Object.keys(o), type: "string", schemaType: "string", $data: !0, error: i, code(e) { const { gen: t, data: r, schemaCode: a, keyword: i, it: c } = e, { opts: u, self: l } = c; if (!u.validateFormats) return; const d = new s.KeywordCxt(c, l.RULES.all.format.definition, "format"); function h(e) { return n._`${e}.compare(${r}, ${a}) ${o[i].fail} 0` } d.$data ? function () { const r = t.scopeValue("formats", { ref: l.formats, code: u.code.formats }), s = t.const("fmt", n._`${r}[${d.schemaCode}]`); e.fail$data(n.or(n._`typeof ${s} != "object"`, n._`${s} instanceof RegExp`, n._`typeof ${s}.compare != "function"`, h(s))) }() : function () { const r = d.schema, s = l.formats[r]; if (!s || !0 === s) return; if ("object" != typeof s || s instanceof RegExp || "function" != typeof s.compare) throw new Error(`"${i}": format "${r}" does not define "compare" function`); const a = t.scopeValue("formats", { key: r, ref: s, code: u.code.formats ? n._`${u.code.formats}${n.getProperty(r)}` : void 0 }); e.fail$data(h(a)) }() }, dependencies: ["format"] }; t.default = e => (e.addKeyword(t.formatLimitDefinition), e) }, 6505: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = { keyword: "anyOf", schemaType: "array", trackErrors: !0, code: r(5765).validateUnion, error: { message: "must match a schema in anyOf" } }; t.default = s }, 6534: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/meta/format","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/format":true},"$recursiveAnchor":true,"title":"Format vocabulary meta-schema","type":["object","boolean"],"properties":{"format":{"type":"string"}}}') }, 6653: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(7652), a = r(3835), o = r(4551), i = r(4227), c = { keyword: "discriminator", type: "object", schemaType: "object", error: { message: ({ params: { discrError: e, tagName: t } }) => e === n.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`, params: ({ params: { discrError: e, tag: t, tagName: r } }) => s._`{error: ${e}, tag: ${r}, tagValue: ${t}}` }, code(e) { const { gen: t, data: r, schema: c, parentSchema: u, it: l } = e, { oneOf: d } = u; if (!l.opts.discriminator) throw new Error("discriminator: requires discriminator option"); const h = c.propertyName; if ("string" != typeof h) throw new Error("discriminator: requires propertyName"); if (c.mapping) throw new Error("discriminator: mapping is not supported"); if (!d) throw new Error("discriminator: requires oneOf keyword"); const m = t.let("valid", !1), f = t.const("tag", s._`${r}${(0, s.getProperty)(h)}`); function p(r) { const n = t.name("valid"), a = e.subschema({ keyword: "oneOf", schemaProp: r }, n); return e.mergeEvaluated(a, s.Name), n } t.if(s._`typeof ${f} == "string"`, () => function () { const r = function () { var e; const t = {}, r = n(u); let s = !0; for (let t = 0; t < d.length; t++) { let u = d[t]; if ((null == u ? void 0 : u.$ref) && !(0, i.schemaHasRulesButRef)(u, l.self.RULES)) { const e = u.$ref; if (u = a.resolveRef.call(l.self, l.schemaEnv.root, l.baseId, e), u instanceof a.SchemaEnv && (u = u.schema), void 0 === u) throw new o.default(l.opts.uriResolver, l.baseId, e) } const m = null === (e = null == u ? void 0 : u.properties) || void 0 === e ? void 0 : e[h]; if ("object" != typeof m) throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${h}"`); s = s && (r || n(u)), c(m, t) } if (!s) throw new Error(`discriminator: "${h}" must be required`); return t; function n({ required: e }) { return Array.isArray(e) && e.includes(h) } function c(e, t) { if (e.const) m(e.const, t); else { if (!e.enum) throw new Error(`discriminator: "properties/${h}" must have "const" or "enum"`); for (const r of e.enum) m(r, t) } } function m(e, r) { if ("string" != typeof e || e in t) throw new Error(`discriminator: "${h}" values must be unique strings`); t[e] = r } }(); t.if(!1); for (const e in r) t.elseIf(s._`${f} === ${e}`), t.assign(m, p(r[e])); t.else(), e.error(!1, { discrError: n.DiscrError.Mapping, tag: f, tagName: h }), t.endIf() }(), () => e.error(!1, { discrError: n.DiscrError.Tag, tag: f, tagName: h })), e.ok(m) } }; t.default = c }, 6939: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.getSchemaRefs = t.resolveUrl = t.normalizeId = t._getFullPath = t.getFullPath = t.inlineRef = void 0; const s = r(4227), n = r(2017), a = r(7106), o = new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]); t.inlineRef = function (e, t = !0) { return "boolean" == typeof e || (!0 === t ? !c(e) : !!t && u(e) <= t) }; const i = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]); function c(e) { for (const t in e) { if (i.has(t)) return !0; const r = e[t]; if (Array.isArray(r) && r.some(c)) return !0; if ("object" == typeof r && c(r)) return !0 } return !1 } function u(e) { let t = 0; for (const r in e) { if ("$ref" === r) return 1 / 0; if (t++, !o.has(r) && ("object" == typeof e[r] && (0, s.eachItem)(e[r], e => t += u(e)), t === 1 / 0)) return 1 / 0 } return t } function l(e, t = "", r) { !1 !== r && (t = m(t)); const s = e.parse(t); return d(e, s) } function d(e, t) { return e.serialize(t).split("#")[0] + "#" } t.getFullPath = l, t._getFullPath = d; const h = /#\/?$/; function m(e) { return e ? e.replace(h, "") : "" } t.normalizeId = m, t.resolveUrl = function (e, t, r) { return r = m(r), e.resolve(t, r) }; const f = /^[a-z_][-a-z0-9._]*$/i; t.getSchemaRefs = function (e, t) { if ("boolean" == typeof e) return {}; const { schemaId: r, uriResolver: s } = this.opts, o = m(e[r] || t), i = { "": o }, c = l(s, o, !1), u = {}, d = new Set; return a(e, { allKeys: !0 }, (e, t, s, n) => { if (void 0 === n) return; const a = c + t; let o = i[n]; function l(t) { const r = this.opts.uriResolver.resolve; if (t = m(o ? r(o, t) : t), d.has(t)) throw p(t); d.add(t); let s = this.refs[t]; return "string" == typeof s && (s = this.refs[s]), "object" == typeof s ? h(e, s.schema, t) : t !== m(a) && ("#" === t[0] ? (h(e, u[t], t), u[t] = e) : this.refs[t] = a), t } function y(e) { if ("string" == typeof e) { if (!f.test(e)) throw new Error(`invalid anchor "${e}"`); l.call(this, `#${e}`) } } "string" == typeof e[r] && (o = l.call(this, e[r])), y.call(this, e.$anchor), y.call(this, e.$dynamicAnchor), i[t] = o }), u; function h(e, t, r) { if (void 0 !== t && !n(e, t)) throw p(r) } function p(e) { return new Error(`reference "${e}" resolves to more than one schema`) } } }, 7060: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(5882), n = r(3439), a = r(7307), o = r(422), i = r(4486), c = r(4003), u = r(1163), l = r(617), d = r(7935), h = r(8643), m = [s.default, n.default, a.default, o.default, i.default, c.default, u.default, l.default, { keyword: "type", schemaType: ["string", "array"] }, { keyword: "nullable", schemaType: "boolean" }, d.default, h.default]; t.default = m }, 7106: e => { var t = e.exports = function (e, t, s) { "function" == typeof t && (s = t, t = {}), r(t, "function" == typeof (s = t.cb || s) ? s : s.pre || function () { }, s.post || function () { }, e, "", e) }; function r(e, n, a, o, i, c, u, l, d, h) { if (o && "object" == typeof o && !Array.isArray(o)) { for (var m in n(o, i, c, u, l, d, h), o) { var f = o[m]; if (Array.isArray(f)) { if (m in t.arrayKeywords) for (var p = 0; p < f.length; p++)r(e, n, a, f[p], i + "/" + m + "/" + p, c, i, m, o, p) } else if (m in t.propsKeywords) { if (f && "object" == typeof f) for (var y in f) r(e, n, a, f[y], i + "/" + m + "/" + s(y), c, i, m, o, y) } else (m in t.keywords || e.allKeys && !(m in t.skipKeywords)) && r(e, n, a, f, i + "/" + m, c, i, m, o) } a(o, i, c, u, l, d, h) } } function s(e) { return e.replace(/~/g, "~0").replace(/\//g, "~1") } t.keywords = { additionalItems: !0, items: !0, contains: !0, additionalProperties: !0, propertyNames: !0, not: !0, if: !0, then: !0, else: !0 }, t.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }, t.propsKeywords = { $defs: !0, definitions: !0, properties: !0, patternProperties: !0, dependencies: !0 }, t.skipKeywords = { default: !0, enum: !0, const: !0, required: !0, maximum: !0, minimum: !0, exclusiveMaximum: !0, exclusiveMinimum: !0, multipleOf: !0, maxLength: !0, minLength: !0, pattern: !0, format: !0, maxItems: !0, minItems: !0, uniqueItems: !0, maxProperties: !0, minProperties: !0 } }, 7307: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = r(3853), o = { keyword: ["maxLength", "minLength"], type: "string", schemaType: "number", $data: !0, error: { message({ keyword: e, schemaCode: t }) { const r = "maxLength" === e ? "more" : "fewer"; return s.str`must NOT have ${r} than ${t} characters` }, params: ({ schemaCode: e }) => s._`{limit: ${e}}` }, code(e) { const { keyword: t, data: r, schemaCode: o, it: i } = e, c = "maxLength" === t ? s.operators.GT : s.operators.LT, u = !1 === i.opts.unicode ? s._`${r}.length` : s._`${(0, n.useFunc)(e.gen, a.default)}(${r})`; e.fail$data(s._`${u} ${c} ${o}`) } }; t.default = o }, 7532: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = [r(4737).default]; t.default = s }, 7652: (e, t) => { var r; Object.defineProperty(t, "__esModule", { value: !0 }), t.DiscrError = void 0, function (e) { e.Tag = "tag", e.Mapping = "mapping" }(r || (t.DiscrError = r = {})) }, 7845: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0; const s = r(1520); class n extends Error { constructor(e) { super(`CodeGen: "code" for ${e} not defined`), this.value = e.value } } var a; !function (e) { e[e.Started = 0] = "Started", e[e.Completed = 1] = "Completed" }(a || (t.UsedValueState = a = {})), t.varKinds = { const: new s.Name("const"), let: new s.Name("let"), var: new s.Name("var") }; class o { constructor({ prefixes: e, parent: t } = {}) { this._names = {}, this._prefixes = e, this._parent = t } toName(e) { return e instanceof s.Name ? e : this.name(e) } name(e) { return new s.Name(this._newName(e)) } _newName(e) { return `${e}${(this._names[e] || this._nameGroup(e)).index++}` } _nameGroup(e) { var t, r; if ((null === (r = null === (t = this._parent) || void 0 === t ? void 0 : t._prefixes) || void 0 === r ? void 0 : r.has(e)) || this._prefixes && !this._prefixes.has(e)) throw new Error(`CodeGen: prefix "${e}" is not allowed in this scope`); return this._names[e] = { prefix: e, index: 0 } } } t.Scope = o; class i extends s.Name { constructor(e, t) { super(t), this.prefix = e } setValue(e, { property: t, itemIndex: r }) { this.value = e, this.scopePath = s._`.${new s.Name(t)}[${r}]` } } t.ValueScopeName = i; const c = s._`\n`; t.ValueScope = class extends o { constructor(e) { super(e), this._values = {}, this._scope = e.scope, this.opts = { ...e, _n: e.lines ? c : s.nil } } get() { return this._scope } name(e) { return new i(e, this._newName(e)) } value(e, t) { var r; if (void 0 === t.ref) throw new Error("CodeGen: ref must be passed in value"); const s = this.toName(e), { prefix: n } = s, a = null !== (r = t.key) && void 0 !== r ? r : t.ref; let o = this._values[n]; if (o) { const e = o.get(a); if (e) return e } else o = this._values[n] = new Map; o.set(a, s); const i = this._scope[n] || (this._scope[n] = []), c = i.length; return i[c] = t.ref, s.setValue(t, { property: n, itemIndex: c }), s } getValue(e, t) { const r = this._values[e]; if (r) return r.get(t) } scopeRefs(e, t = this._values) { return this._reduceValues(t, t => { if (void 0 === t.scopePath) throw new Error(`CodeGen: name "${t}" has no value`); return s._`${e}${t.scopePath}` }) } scopeCode(e = this._values, t, r) { return this._reduceValues(e, e => { if (void 0 === e.value) throw new Error(`CodeGen: name "${e}" has no value`); return e.value.code }, t, r) } _reduceValues(e, r, o = {}, i) { let c = s.nil; for (const u in e) { const l = e[u]; if (!l) continue; const d = o[u] = o[u] || new Map; l.forEach(e => { if (d.has(e)) return; d.set(e, a.Started); let o = r(e); if (o) { const r = this.opts.es5 ? t.varKinds.var : t.varKinds.const; c = s._`${c}${r} ${e} = ${o};${this.opts._n}` } else { if (!(o = null == i ? void 0 : i(e))) throw new n(e); c = s._`${c}${o}${this.opts._n}` } d.set(e, a.Completed) }) } return c } } }, 7870: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.assignDefaults = void 0; const s = r(9029), n = r(4227); function a(e, t, r) { const { gen: a, compositeRule: o, data: i, opts: c } = e; if (void 0 === r) return; const u = s._`${i}${(0, s.getProperty)(t)}`; if (o) return void (0, n.checkStrictMode)(e, `default is ignored for: ${u}`); let l = s._`${u} === undefined`; "empty" === c.useDefaults && (l = s._`${l} || ${u} === null || ${u} === ""`), a.if(l, s._`${u} = ${(0, s.stringify)(r)}`) } t.assignDefaults = function (e, t) { const { properties: r, items: s } = e.schema; if ("object" === t && r) for (const t in r) a(e, t, r[t].default); else "array" === t && Array.isArray(s) && s.forEach((t, r) => a(e, r, t.default)) } }, 7887: (e, t) => { function r(e, t) { return t.rules.some(t => s(e, t)) } function s(e, t) { var r; return void 0 !== e[t.keyword] || (null === (r = t.definition.implements) || void 0 === r ? void 0 : r.some(t => void 0 !== e[t])) } Object.defineProperty(t, "__esModule", { value: !0 }), t.shouldUseRule = t.shouldUseGroup = t.schemaHasRulesForType = void 0, t.schemaHasRulesForType = function ({ schema: e, self: t }, s) { const n = t.RULES.types[s]; return n && !0 !== n && r(e, n) }, t.shouldUseGroup = r, t.shouldUseRule = s }, 7923: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(4227), n = { keyword: "not", schemaType: ["object", "boolean"], trackErrors: !0, code(e) { const { gen: t, schema: r, it: n } = e; if ((0, s.alwaysValidSchema)(n, r)) return void e.fail(); const a = t.name("valid"); e.subschema({ keyword: "not", compositeRule: !0, createErrors: !1, allErrors: !1 }, a), e.failResult(a, () => e.reset(), () => e.error()) }, error: { message: "must NOT be valid" } }; t.default = n }, 7935: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = r(6250), o = { keyword: "const", $data: !0, error: { message: "must be equal to constant", params: ({ schemaCode: e }) => s._`{allowedValue: ${e}}` }, code(e) { const { gen: t, data: r, $data: o, schemaCode: i, schema: c } = e; o || c && "object" == typeof c ? e.fail$data(s._`!${(0, n.useFunc)(t, a.default)}(${r}, ${i})`) : e.fail(s._`${c} !== ${r}`) } }; t.default = o }, 8030: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/meta/validation","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/validation":true},"$recursiveAnchor":true,"title":"Validation vocabulary meta-schema","type":["object","boolean"],"properties":{"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/$defs/nonNegativeInteger"},"minLength":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"maxItems":{"$ref":"#/$defs/nonNegativeInteger"},"minItems":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"maxContains":{"$ref":"#/$defs/nonNegativeInteger"},"minContains":{"$ref":"#/$defs/nonNegativeInteger","default":1},"maxProperties":{"$ref":"#/$defs/nonNegativeInteger"},"minProperties":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"required":{"$ref":"#/$defs/stringArray"},"dependentRequired":{"type":"object","additionalProperties":{"$ref":"#/$defs/stringArray"}},"const":true,"enum":{"type":"array","items":true},"type":{"anyOf":[{"$ref":"#/$defs/simpleTypes"},{"type":"array","items":{"$ref":"#/$defs/simpleTypes"},"minItems":1,"uniqueItems":true}]}},"$defs":{"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"$ref":"#/$defs/nonNegativeInteger","default":0},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}}}') }, 8138: e => { e.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://json-schema.org/draft/2019-09/schema","$vocabulary":{"https://json-schema.org/draft/2019-09/vocab/core":true,"https://json-schema.org/draft/2019-09/vocab/applicator":true,"https://json-schema.org/draft/2019-09/vocab/validation":true,"https://json-schema.org/draft/2019-09/vocab/meta-data":true,"https://json-schema.org/draft/2019-09/vocab/format":false,"https://json-schema.org/draft/2019-09/vocab/content":true},"$recursiveAnchor":true,"title":"Core and Validation specifications meta-schema","allOf":[{"$ref":"meta/core"},{"$ref":"meta/applicator"},{"$ref":"meta/validation"},{"$ref":"meta/meta-data"},{"$ref":"meta/format"},{"$ref":"meta/content"}],"type":["object","boolean"],"properties":{"definitions":{"$comment":"While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.","type":"object","additionalProperties":{"$recursiveRef":"#"},"default":{}},"dependencies":{"$comment":"\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"","type":"object","additionalProperties":{"anyOf":[{"$recursiveRef":"#"},{"$ref":"meta/validation#/$defs/stringArray"}]}}}}') }, 8182: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(4018), n = r(6461), a = r(9029), o = new a.Name("fullFormats"), i = new a.Name("fastFormats"), c = (e, t = { keywords: !0 }) => { if (Array.isArray(t)) return u(e, t, s.fullFormats, o), e; const [r, a] = "fast" === t.mode ? [s.fastFormats, i] : [s.fullFormats, o]; return u(e, t.formats || s.formatNames, r, a), t.keywords && n.default(e), e }; function u(e, t, r, s) { var n, o; null !== (n = (o = e.opts.code).formats) && void 0 !== n || (o.formats = a._`require("ajv-formats/dist/formats").${s}`); for (const s of t) e.addFormat(s, r[s]) } c.get = (e, t = "full") => { const r = ("fast" === t ? s.fastFormats : s.fullFormats)[e]; if (!r) throw new Error(`Unknown format "${e}"`); return r }, e.exports = t = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c }, 8343: (e, t, r) => { const { normalizeIPv6: s, normalizeIPv4: n, removeDotSegments: a, recomposeAuthority: o, normalizeComponentEncoding: i } = r(4834), c = r(343); function u(e, t, r, s) { const n = {}; return s || (e = m(l(e, r), r), t = m(l(t, r), r)), !(r = r || {}).tolerant && t.scheme ? (n.scheme = t.scheme, n.userinfo = t.userinfo, n.host = t.host, n.port = t.port, n.path = a(t.path || ""), n.query = t.query) : (void 0 !== t.userinfo || void 0 !== t.host || void 0 !== t.port ? (n.userinfo = t.userinfo, n.host = t.host, n.port = t.port, n.path = a(t.path || ""), n.query = t.query) : (t.path ? ("/" === t.path.charAt(0) ? n.path = a(t.path) : (void 0 === e.userinfo && void 0 === e.host && void 0 === e.port || e.path ? e.path ? n.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : n.path = t.path : n.path = "/" + t.path, n.path = a(n.path)), n.query = t.query) : (n.path = e.path, void 0 !== t.query ? n.query = t.query : n.query = e.query), n.userinfo = e.userinfo, n.host = e.host, n.port = e.port), n.scheme = e.scheme), n.fragment = t.fragment, n } function l(e, t) { const r = { host: e.host, scheme: e.scheme, userinfo: e.userinfo, port: e.port, path: e.path, query: e.query, nid: e.nid, nss: e.nss, uuid: e.uuid, fragment: e.fragment, reference: e.reference, resourceName: e.resourceName, secure: e.secure, error: "" }, s = Object.assign({}, t), n = [], i = c[(s.scheme || r.scheme || "").toLowerCase()]; i && i.serialize && i.serialize(r, s), void 0 !== r.path && (s.skipEscape ? r.path = unescape(r.path) : (r.path = escape(r.path), void 0 !== r.scheme && (r.path = r.path.split("%3A").join(":")))), "suffix" !== s.reference && r.scheme && n.push(r.scheme, ":"); const u = o(r); if (void 0 !== u && ("suffix" !== s.reference && n.push("//"), n.push(u), r.path && "/" !== r.path.charAt(0) && n.push("/")), void 0 !== r.path) { let e = r.path; s.absolutePath || i && i.absolutePath || (e = a(e)), void 0 === u && (e = e.replace(/^\/\//u, "/%2F")), n.push(e) } return void 0 !== r.query && n.push("?", r.query), void 0 !== r.fragment && n.push("#", r.fragment), n.join("") } const d = Array.from({ length: 127 }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t))); const h = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u; function m(e, t) { const r = Object.assign({}, t), a = { scheme: void 0, userinfo: void 0, host: "", port: void 0, path: "", query: void 0, fragment: void 0 }, o = -1 !== e.indexOf("%"); let i = !1; "suffix" === r.reference && (e = (r.scheme ? r.scheme + ":" : "") + "//" + e); const u = e.match(h); if (u) { if (a.scheme = u[1], a.userinfo = u[3], a.host = u[4], a.port = parseInt(u[5], 10), a.path = u[6] || "", a.query = u[7], a.fragment = u[8], isNaN(a.port) && (a.port = u[5]), a.host) { const e = n(a.host); if (!1 === e.isIPV4) { const t = s(e.host); a.host = t.host.toLowerCase(), i = t.isIPV6 } else a.host = e.host, i = !0 } void 0 !== a.scheme || void 0 !== a.userinfo || void 0 !== a.host || void 0 !== a.port || void 0 !== a.query || a.path ? void 0 === a.scheme ? a.reference = "relative" : void 0 === a.fragment ? a.reference = "absolute" : a.reference = "uri" : a.reference = "same-document", r.reference && "suffix" !== r.reference && r.reference !== a.reference && (a.error = a.error || "URI is not a " + r.reference + " reference."); const e = c[(r.scheme || a.scheme || "").toLowerCase()]; if (!(r.unicodeSupport || e && e.unicodeSupport) && a.host && (r.domainHost || e && e.domainHost) && !1 === i && function (e) { let t = 0; for (let r = 0, s = e.length; r < s; ++r)if (t = e.charCodeAt(r), t > 126 || d[t]) return !0; return !1 }(a.host)) try { a.host = URL.domainToASCII(a.host.toLowerCase()) } catch (e) { a.error = a.error || "Host's domain name can not be converted to ASCII: " + e } (!e || e && !e.skipNormalize) && (o && void 0 !== a.scheme && (a.scheme = unescape(a.scheme)), o && void 0 !== a.host && (a.host = unescape(a.host)), a.path && (a.path = escape(unescape(a.path))), a.fragment && (a.fragment = encodeURI(decodeURIComponent(a.fragment)))), e && e.parse && e.parse(a, r) } else a.error = a.error || "URI can not be parsed."; return a } const f = { SCHEMES: c, normalize: function (e, t) { return "string" == typeof e ? e = l(m(e, t), t) : "object" == typeof e && (e = m(l(e, t), t)), e }, resolve: function (e, t, r) { const s = Object.assign({ scheme: "null" }, r); return l(u(m(e, s), m(t, s), s, !0), { ...s, skipEscape: !0 }) }, resolveComponents: u, equal: function (e, t, r) { return "string" == typeof e ? (e = unescape(e), e = l(i(m(e, r), !0), { ...r, skipEscape: !0 })) : "object" == typeof e && (e = l(i(e, !0), { ...r, skipEscape: !0 })), "string" == typeof t ? (t = unescape(t), t = l(i(m(t, r), !0), { ...r, skipEscape: !0 })) : "object" == typeof t && (t = l(i(t, !0), { ...r, skipEscape: !0 })), e.toLowerCase() === t.toLowerCase() }, serialize: l, parse: m }; e.exports = f, e.exports.default = f, e.exports.fastUri = f }, 8643: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = r(6250), o = { keyword: "enum", schemaType: "array", $data: !0, error: { message: "must be equal to one of the allowed values", params: ({ schemaCode: e }) => s._`{allowedValues: ${e}}` }, code(e) { const { gen: t, data: r, $data: o, schema: i, schemaCode: c, it: u } = e; if (!o && 0 === i.length) throw new Error("enum must have non-empty array"); const l = i.length >= u.opts.loopEnum; let d; const h = () => null != d ? d : d = (0, n.useFunc)(t, a.default); let m; if (l || o) m = t.let("valid"), e.block$data(m, function () { t.assign(m, !1), t.forOf("v", c, e => t.if(s._`${h()}(${r}, ${e})`, () => t.assign(m, !0).break())) }); else { if (!Array.isArray(i)) throw new Error("ajv implementation error"); const e = t.const("vSchema", c); m = (0, s.or)(...i.map((t, n) => function (e, t) { const n = i[t]; return "object" == typeof n && null !== n ? s._`${h()}(${r}, ${e}[${t}])` : s._`${r} === ${n}` }(e, n))) } e.pass(m) } }; t.default = o }, 8660: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(5765), n = r(9029), a = r(2023), o = r(4227), i = { keyword: "additionalProperties", type: ["object"], schemaType: ["boolean", "object"], allowUndefined: !0, trackErrors: !0, error: { message: "must NOT have additional properties", params: ({ params: e }) => n._`{additionalProperty: ${e.additionalProperty}}` }, code(e) { const { gen: t, schema: r, parentSchema: i, data: c, errsCount: u, it: l } = e; if (!u) throw new Error("ajv implementation error"); const { allErrors: d, opts: h } = l; if (l.props = !0, "all" !== h.removeAdditional && (0, o.alwaysValidSchema)(l, r)) return; const m = (0, s.allSchemaProperties)(i.properties), f = (0, s.allSchemaProperties)(i.patternProperties); function p(e) { t.code(n._`delete ${c}[${e}]`) } function y(s) { if ("all" === h.removeAdditional || h.removeAdditional && !1 === r) p(s); else { if (!1 === r) return e.setParams({ additionalProperty: s }), e.error(), void (d || t.break()); if ("object" == typeof r && !(0, o.alwaysValidSchema)(l, r)) { const r = t.name("valid"); "failing" === h.removeAdditional ? (g(s, r, !1), t.if((0, n.not)(r), () => { e.reset(), p(s) })) : (g(s, r), d || t.if((0, n.not)(r), () => t.break())) } } } function g(t, r, s) { const n = { keyword: "additionalProperties", dataProp: t, dataPropType: o.Type.Str }; !1 === s && Object.assign(n, { compositeRule: !0, createErrors: !1, allErrors: !1 }), e.subschema(n, r) } t.forIn("key", c, r => { m.length || f.length ? t.if(function (r) { let a; if (m.length > 8) { const e = (0, o.schemaRefOrVal)(l, i.properties, "properties"); a = (0, s.isOwnProperty)(t, e, r) } else a = m.length ? (0, n.or)(...m.map(e => n._`${r} === ${e}`)) : n.nil; return f.length && (a = (0, n.or)(a, ...f.map(t => n._`${(0, s.usePattern)(e, t)}.test(${r})`))), (0, n.not)(a) }(r), () => y(r)) : y(r) }), e.ok(n._`${u} === ${a.default.errors}`) } }; t.default = i }, 8708: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0; const s = r(9029), n = r(4227), a = r(2023); function o(e, t) { const r = e.const("err", t); e.if(s._`${a.default.vErrors} === null`, () => e.assign(a.default.vErrors, s._`[${r}]`), s._`${a.default.vErrors}.push(${r})`), e.code(s._`${a.default.errors}++`) } function i(e, t) { const { gen: r, validateName: n, schemaEnv: a } = e; a.$async ? r.throw(s._`new ${e.ValidationError}(${t})`) : (r.assign(s._`${n}.errors`, t), r.return(!1)) } t.keywordError = { message: ({ keyword: e }) => s.str`must pass "${e}" keyword validation` }, t.keyword$DataError = { message: ({ keyword: e, schemaType: t }) => t ? s.str`"${e}" keyword must be ${t} ($data)` : s.str`"${e}" keyword is invalid ($data)` }, t.reportError = function (e, r = t.keywordError, n, a) { const { it: c } = e, { gen: l, compositeRule: d, allErrors: h } = c, m = u(e, r, n); (null != a ? a : d || h) ? o(l, m) : i(c, s._`[${m}]`) }, t.reportExtraError = function (e, r = t.keywordError, s) { const { it: n } = e, { gen: c, compositeRule: l, allErrors: d } = n; o(c, u(e, r, s)), l || d || i(n, a.default.vErrors) }, t.resetErrorsCount = function (e, t) { e.assign(a.default.errors, t), e.if(s._`${a.default.vErrors} !== null`, () => e.if(t, () => e.assign(s._`${a.default.vErrors}.length`, t), () => e.assign(a.default.vErrors, null))) }, t.extendErrors = function ({ gen: e, keyword: t, schemaValue: r, data: n, errsCount: o, it: i }) { if (void 0 === o) throw new Error("ajv implementation error"); const c = e.name("err"); e.forRange("i", o, a.default.errors, o => { e.const(c, s._`${a.default.vErrors}[${o}]`), e.if(s._`${c}.instancePath === undefined`, () => e.assign(s._`${c}.instancePath`, (0, s.strConcat)(a.default.instancePath, i.errorPath))), e.assign(s._`${c}.schemaPath`, s.str`${i.errSchemaPath}/${t}`), i.opts.verbose && (e.assign(s._`${c}.schema`, r), e.assign(s._`${c}.data`, n)) }) }; const c = { keyword: new s.Name("keyword"), schemaPath: new s.Name("schemaPath"), params: new s.Name("params"), propertyName: new s.Name("propertyName"), message: new s.Name("message"), schema: new s.Name("schema"), parentSchema: new s.Name("parentSchema") }; function u(e, t, r) { const { createErrors: n } = e.it; return !1 === n ? s._`{}` : function (e, t, r = {}) { const { gen: n, it: o } = e, i = [l(o, r), d(e, r)]; return function (e, { params: t, message: r }, n) { const { keyword: o, data: i, schemaValue: u, it: l } = e, { opts: d, propertyName: h, topSchemaRef: m, schemaPath: f } = l; n.push([c.keyword, o], [c.params, "function" == typeof t ? t(e) : t || s._`{}`]), d.messages && n.push([c.message, "function" == typeof r ? r(e) : r]); d.verbose && n.push([c.schema, u], [c.parentSchema, s._`${m}${f}`], [a.default.data, i]); h && n.push([c.propertyName, h]) }(e, t, i), n.object(...i) }(e, t, r) } function l({ errorPath: e }, { instancePath: t }) { const r = t ? s.str`${e}${(0, n.getErrorPath)(t, n.Type.Str)}` : e; return [a.default.instancePath, (0, s.strConcat)(a.default.instancePath, r)] } function d({ keyword: e, it: { errSchemaPath: t } }, { schemaPath: r, parentSchema: a }) { let o = a ? t : s.str`${t}/${e}`; return r && (o = s.str`${o}${(0, n.getErrorPath)(r, n.Type.Str)}`), [c.schemaPath, o] } }, 8727: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.boolOrEmptySchema = t.topBoolOrEmptySchema = void 0; const s = r(8708), n = r(9029), a = r(2023), o = { message: "boolean schema is false" }; function i(e, t) { const { gen: r, data: n } = e, a = { gen: r, keyword: "false schema", data: n, schema: !1, schemaCode: !1, schemaValue: !1, params: {}, it: e }; (0, s.reportError)(a, o, void 0, t) } t.topBoolOrEmptySchema = function (e) { const { gen: t, schema: r, validateName: s } = e; !1 === r ? i(e, !1) : "object" == typeof r && !0 === r.$async ? t.return(a.default.data) : (t.assign(n._`${s}.errors`, null), t.return(!0)) }, t.boolOrEmptySchema = function (e, t) { const { gen: r, schema: s } = e; !1 === s ? (r.var(t, !1), i(e)) : r.var(t, !0) } }, 9029: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0; const s = r(1520), n = r(7845); var a = r(1520); Object.defineProperty(t, "_", { enumerable: !0, get: function () { return a._ } }), Object.defineProperty(t, "str", { enumerable: !0, get: function () { return a.str } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function () { return a.strConcat } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function () { return a.nil } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function () { return a.getProperty } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function () { return a.stringify } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function () { return a.regexpCode } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function () { return a.Name } }); var o = r(7845); Object.defineProperty(t, "Scope", { enumerable: !0, get: function () { return o.Scope } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function () { return o.ValueScope } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function () { return o.ValueScopeName } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function () { return o.varKinds } }), t.operators = { GT: new s._Code(">"), GTE: new s._Code(">="), LT: new s._Code("<"), LTE: new s._Code("<="), EQ: new s._Code("==="), NEQ: new s._Code("!=="), NOT: new s._Code("!"), OR: new s._Code("||"), AND: new s._Code("&&"), ADD: new s._Code("+") }; class i { optimizeNodes() { return this } optimizeNames(e, t) { return this } } class c extends i { constructor(e, t, r) { super(), this.varKind = e, this.name = t, this.rhs = r } render({ es5: e, _n: t }) { const r = e ? n.varKinds.var : this.varKind, s = void 0 === this.rhs ? "" : ` = ${this.rhs}`; return `${r} ${this.name}${s};` + t } optimizeNames(e, t) { if (e[this.name.str]) return this.rhs && (this.rhs = x(this.rhs, e, t)), this } get names() { return this.rhs instanceof s._CodeOrName ? this.rhs.names : {} } } class u extends i { constructor(e, t, r) { super(), this.lhs = e, this.rhs = t, this.sideEffects = r } render({ _n: e }) { return `${this.lhs} = ${this.rhs};` + e } optimizeNames(e, t) { if (!(this.lhs instanceof s.Name) || e[this.lhs.str] || this.sideEffects) return this.rhs = x(this.rhs, e, t), this } get names() { return T(this.lhs instanceof s.Name ? {} : { ...this.lhs.names }, this.rhs) } } class l extends u { constructor(e, t, r, s) { super(e, r, s), this.op = t } render({ _n: e }) { return `${this.lhs} ${this.op}= ${this.rhs};` + e } } class d extends i { constructor(e) { super(), this.label = e, this.names = {} } render({ _n: e }) { return `${this.label}:` + e } } class h extends i { constructor(e) { super(), this.label = e, this.names = {} } render({ _n: e }) { return `break${this.label ? ` ${this.label}` : ""};` + e } } class m extends i { constructor(e) { super(), this.error = e } render({ _n: e }) { return `throw ${this.error};` + e } get names() { return this.error.names } } class f extends i { constructor(e) { super(), this.code = e } render({ _n: e }) { return `${this.code};` + e } optimizeNodes() { return `${this.code}` ? this : void 0 } optimizeNames(e, t) { return this.code = x(this.code, e, t), this } get names() { return this.code instanceof s._CodeOrName ? this.code.names : {} } } class p extends i { constructor(e = []) { super(), this.nodes = e } render(e) { return this.nodes.reduce((t, r) => t + r.render(e), "") } optimizeNodes() { const { nodes: e } = this; let t = e.length; for (; t--;) { const r = e[t].optimizeNodes(); Array.isArray(r) ? e.splice(t, 1, ...r) : r ? e[t] = r : e.splice(t, 1) } return e.length > 0 ? this : void 0 } optimizeNames(e, t) { const { nodes: r } = this; let s = r.length; for (; s--;) { const n = r[s]; n.optimizeNames(e, t) || (I(e, n.names), r.splice(s, 1)) } return r.length > 0 ? this : void 0 } get names() { return this.nodes.reduce((e, t) => j(e, t.names), {}) } } class y extends p { render(e) { return "{" + e._n + super.render(e) + "}" + e._n } } class g extends p { } class v extends y { } v.kind = "else"; class $ extends y { constructor(e, t) { super(t), this.condition = e } render(e) { let t = `if(${this.condition})` + super.render(e); return this.else && (t += "else " + this.else.render(e)), t } optimizeNodes() { super.optimizeNodes(); const e = this.condition; if (!0 === e) return this.nodes; let t = this.else; if (t) { const e = t.optimizeNodes(); t = this.else = Array.isArray(e) ? new v(e) : e } return t ? !1 === e ? t instanceof $ ? t : t.nodes : this.nodes.length ? this : new $(M(e), t instanceof $ ? [t] : t.nodes) : !1 !== e && this.nodes.length ? this : void 0 } optimizeNames(e, t) { var r; if (this.else = null === (r = this.else) || void 0 === r ? void 0 : r.optimizeNames(e, t), super.optimizeNames(e, t) || this.else) return this.condition = x(this.condition, e, t), this } get names() { const e = super.names; return T(e, this.condition), this.else && j(e, this.else.names), e } } $.kind = "if"; class w extends y { } w.kind = "for"; class b extends w { constructor(e) { super(), this.iteration = e } render(e) { return `for(${this.iteration})` + super.render(e) } optimizeNames(e, t) { if (super.optimizeNames(e, t)) return this.iteration = x(this.iteration, e, t), this } get names() { return j(super.names, this.iteration.names) } } class _ extends w { constructor(e, t, r, s) { super(), this.varKind = e, this.name = t, this.from = r, this.to = s } render(e) { const t = e.es5 ? n.varKinds.var : this.varKind, { name: r, from: s, to: a } = this; return `for(${t} ${r}=${s}; ${r}<${a}; ${r}++)` + super.render(e) } get names() { const e = T(super.names, this.from); return T(e, this.to) } } class k extends w { constructor(e, t, r, s) { super(), this.loop = e, this.varKind = t, this.name = r, this.iterable = s } render(e) { return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(e) } optimizeNames(e, t) { if (super.optimizeNames(e, t)) return this.iterable = x(this.iterable, e, t), this } get names() { return j(super.names, this.iterable.names) } } class S extends y { constructor(e, t, r) { super(), this.name = e, this.args = t, this.async = r } render(e) { return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(e) } } S.kind = "func"; class N extends p { render(e) { return "return " + super.render(e) } } N.kind = "return"; class O extends y { render(e) { let t = "try" + super.render(e); return this.catch && (t += this.catch.render(e)), this.finally && (t += this.finally.render(e)), t } optimizeNodes() { var e, t; return super.optimizeNodes(), null === (e = this.catch) || void 0 === e || e.optimizeNodes(), null === (t = this.finally) || void 0 === t || t.optimizeNodes(), this } optimizeNames(e, t) { var r, s; return super.optimizeNames(e, t), null === (r = this.catch) || void 0 === r || r.optimizeNames(e, t), null === (s = this.finally) || void 0 === s || s.optimizeNames(e, t), this } get names() { const e = super.names; return this.catch && j(e, this.catch.names), this.finally && j(e, this.finally.names), e } } class E extends y { constructor(e) { super(), this.error = e } render(e) { return `catch(${this.error})` + super.render(e) } } E.kind = "catch"; class P extends y { render(e) { return "finally" + super.render(e) } } P.kind = "finally"; function j(e, t) { for (const r in t) e[r] = (e[r] || 0) + (t[r] || 0); return e } function T(e, t) { return t instanceof s._CodeOrName ? j(e, t.names) : e } function x(e, t, r) { return e instanceof s.Name ? a(e) : (n = e) instanceof s._Code && n._items.some(e => e instanceof s.Name && 1 === t[e.str] && void 0 !== r[e.str]) ? new s._Code(e._items.reduce((e, t) => (t instanceof s.Name && (t = a(t)), t instanceof s._Code ? e.push(...t._items) : e.push(t), e), [])) : e; var n; function a(e) { const s = r[e.str]; return void 0 === s || 1 !== t[e.str] ? e : (delete t[e.str], s) } } function I(e, t) { for (const r in t) e[r] = (e[r] || 0) - (t[r] || 0) } function M(e) { return "boolean" == typeof e || "number" == typeof e || null === e ? !e : s._`!${V(e)}` } t.CodeGen = class { constructor(e, t = {}) { this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...t, _n: t.lines ? "\n" : "" }, this._extScope = e, this._scope = new n.Scope({ parent: e }), this._nodes = [new g] } toString() { return this._root.render(this.opts) } name(e) { return this._scope.name(e) } scopeName(e) { return this._extScope.name(e) } scopeValue(e, t) { const r = this._extScope.value(e, t); return (this._values[r.prefix] || (this._values[r.prefix] = new Set)).add(r), r } getScopeValue(e, t) { return this._extScope.getValue(e, t) } scopeRefs(e) { return this._extScope.scopeRefs(e, this._values) } scopeCode() { return this._extScope.scopeCode(this._values) } _def(e, t, r, s) { const n = this._scope.toName(t); return void 0 !== r && s && (this._constants[n.str] = r), this._leafNode(new c(e, n, r)), n } const(e, t, r) { return this._def(n.varKinds.const, e, t, r) } let(e, t, r) { return this._def(n.varKinds.let, e, t, r) } var(e, t, r) { return this._def(n.varKinds.var, e, t, r) } assign(e, t, r) { return this._leafNode(new u(e, t, r)) } add(e, r) { return this._leafNode(new l(e, t.operators.ADD, r)) } code(e) { return "function" == typeof e ? e() : e !== s.nil && this._leafNode(new f(e)), this } object(...e) { const t = ["{"]; for (const [r, n] of e) t.length > 1 && t.push(","), t.push(r), (r !== n || this.opts.es5) && (t.push(":"), (0, s.addCodeArg)(t, n)); return t.push("}"), new s._Code(t) } if(e, t, r) { if (this._blockNode(new $(e)), t && r) this.code(t).else().code(r).endIf(); else if (t) this.code(t).endIf(); else if (r) throw new Error('CodeGen: "else" body without "then" body'); return this } elseIf(e) { return this._elseNode(new $(e)) } else() { return this._elseNode(new v) } endIf() { return this._endBlockNode($, v) } _for(e, t) { return this._blockNode(e), t && this.code(t).endFor(), this } for(e, t) { return this._for(new b(e), t) } forRange(e, t, r, s, a = (this.opts.es5 ? n.varKinds.var : n.varKinds.let)) { const o = this._scope.toName(e); return this._for(new _(a, o, t, r), () => s(o)) } forOf(e, t, r, a = n.varKinds.const) { const o = this._scope.toName(e); if (this.opts.es5) { const e = t instanceof s.Name ? t : this.var("_arr", t); return this.forRange("_i", 0, s._`${e}.length`, t => { this.var(o, s._`${e}[${t}]`), r(o) }) } return this._for(new k("of", a, o, t), () => r(o)) } forIn(e, t, r, a = (this.opts.es5 ? n.varKinds.var : n.varKinds.const)) { if (this.opts.ownProperties) return this.forOf(e, s._`Object.keys(${t})`, r); const o = this._scope.toName(e); return this._for(new k("in", a, o, t), () => r(o)) } endFor() { return this._endBlockNode(w) } label(e) { return this._leafNode(new d(e)) } break(e) { return this._leafNode(new h(e)) } return(e) { const t = new N; if (this._blockNode(t), this.code(e), 1 !== t.nodes.length) throw new Error('CodeGen: "return" should have one node'); return this._endBlockNode(N) } try(e, t, r) { if (!t && !r) throw new Error('CodeGen: "try" without "catch" and "finally"'); const s = new O; if (this._blockNode(s), this.code(e), t) { const e = this.name("e"); this._currNode = s.catch = new E(e), t(e) } return r && (this._currNode = s.finally = new P, this.code(r)), this._endBlockNode(E, P) } throw(e) { return this._leafNode(new m(e)) } block(e, t) { return this._blockStarts.push(this._nodes.length), e && this.code(e).endBlock(t), this } endBlock(e) { const t = this._blockStarts.pop(); if (void 0 === t) throw new Error("CodeGen: not in self-balancing block"); const r = this._nodes.length - t; if (r < 0 || void 0 !== e && r !== e) throw new Error(`CodeGen: wrong number of nodes: ${r} vs ${e} expected`); return this._nodes.length = t, this } func(e, t = s.nil, r, n) { return this._blockNode(new S(e, t, r)), n && this.code(n).endFunc(), this } endFunc() { return this._endBlockNode(S) } optimize(e = 1) { for (; e-- > 0;)this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants) } _leafNode(e) { return this._currNode.nodes.push(e), this } _blockNode(e) { this._currNode.nodes.push(e), this._nodes.push(e) } _endBlockNode(e, t) { const r = this._currNode; if (r instanceof e || t && r instanceof t) return this._nodes.pop(), this; throw new Error(`CodeGen: not in block "${t ? `${e.kind}/${t.kind}` : e.kind}"`) } _elseNode(e) { const t = this._currNode; if (!(t instanceof $)) throw new Error('CodeGen: "else" without "if"'); return this._currNode = t.else = e, this } get _root() { return this._nodes[0] } get _currNode() { const e = this._nodes; return e[e.length - 1] } set _currNode(e) { const t = this._nodes; t[t.length - 1] = e } }, t.not = M; const C = R(t.operators.AND); t.and = function (...e) { return e.reduce(C) }; const D = R(t.operators.OR); function R(e) { return (t, r) => t === s.nil ? r : r === s.nil ? t : s._`${V(t)} ${e} ${V(r)}` } function V(e) { return e instanceof s.Name ? e : s._`(${e})` } t.or = function (...e) { return e.reduce(D) } }, 9713: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9029), n = r(4227), a = { keyword: "propertyNames", type: "object", schemaType: ["object", "boolean"], error: { message: "property name must be valid", params: ({ params: e }) => s._`{propertyName: ${e.propertyName}}` }, code(e) { const { gen: t, schema: r, data: a, it: o } = e; if ((0, n.alwaysValidSchema)(o, r)) return; const i = t.name("valid"); t.forIn("key", a, r => { e.setParams({ propertyName: r }), e.subschema({ keyword: "propertyNames", data: r, dataTypes: ["string"], propertyName: r, compositeRule: !0 }, i), t.if((0, s.not)(i), () => { e.error(!0), o.allErrors || t.break() }) }), e.ok(i) } }; t.default = a }, 9857: (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.contentVocabulary = t.metadataVocabulary = void 0, t.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"], t.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"] }
    }, t = {}; function r(s) { var n = t[s]; if (void 0 !== n) return n.exports; var a = t[s] = { exports: {} }; return e[s](a, a.exports, r), a.exports } r.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return r.d(t, { a: t }), t }, r.d = (e, t) => { for (var s in t) r.o(t, s) && !r.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: t[s] }) }, r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var s = {}; r.r(s), r.d(s, { And: () => u, Atom: () => Us, Calculation: () => Gs, Comparison: () => Ys, DateCalculation: () => en, DefaultConsoleLogger: () => tn, Formula: () => i, HasNoLengthError: () => Rs, InternalError: () => Cs, InvalidTypeError: () => Ds, Macro: () => Qs, Not: () => l, NotBooleanError: () => Vs, NotDateError: () => zs, NotDurationError: () => qs, NotNumberError: () => As, NotNumberOrDateError: () => Fs, Operator: () => c, Or: () => d, Parser: () => vn, Plugin: () => Xs, Quantifier: () => Bs, RitaError: () => js, Rule: () => o, RulesetError: () => Ms, UndefinedPathError: () => Is, UnimplementedError: () => xs, UsageError: () => Ts, comparisons: () => Zs, dateOperations: () => Js, evaluateAll: () => a, logger: () => rn, mapArgumentsToJSONReady: () => Ks, operations: () => Ws, parseDate: () => Ls, setLogger: () => sn, version: () => $n }); function n(e, t, r, s) { return new (r || (r = Promise))(function (n, a) { function o(e) { try { c(s.next(e)) } catch (e) { a(e) } } function i(e) { try { c(s.throw(e)) } catch (e) { a(e) } } function c(e) { var t; e.done ? n(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) { e(t) })).then(o, i) } c((s = s.apply(e, t || [])).next()) }) } Object.create; Object.create; "function" == typeof SuppressedError && SuppressedError; function a(e, t) { return n(this, void 0, void 0, function* () { const r = { result: !0, details: [], counts: { true: 0, false: 0 } }; for (const s of e) { let e = yield s.evaluate(t); e ? r.counts.true++ : r.counts.false++, r.result = r.result && e, r.details.push({ id: s.id, result: e }) } return r }) } class o { constructor(e, t, r = "") { this.id = e, this.rule = t, this.comment = r } evaluate(e) { return n(this, void 0, void 0, function* () { return yield this.rule.evaluate(e) }) } toJsonReady() { return { id: this.id, rule: this.rule.toJsonReady(), comment: this.comment } } } class i { } class c extends i { constructor(e) { super(), this.arguments = e } validate() { return this.arguments.map(e => e.validate()).reduce((e, t) => e && t) } evaluateReduce(e, t, r = Promise.resolve(!1)) { return this.arguments.reduce((r, s) => n(this, void 0, void 0, function* () { return t(yield r, yield s.evaluate(e)) }), r) } toJsonReady() { return { arguments: this.arguments.map(e => e.toJsonReady()) } } } class u extends c { evaluate(e) { return this.evaluateReduce(e, (e, t) => e && t, Promise.resolve(!0)) } validate() { return this.arguments.length > 1 && super.validate() } toJsonReady() { return Object.assign(Object.assign({}, super.toJsonReady()), { type: "and" }) } } class l extends c { evaluate(e) { return n(this, void 0, void 0, function* () { return Promise.resolve(!(yield this.arguments[0].evaluate(e))) }) } validate() { return 1 === this.arguments.length && super.validate() } toJsonReady() { return Object.assign(Object.assign({}, super.toJsonReady()), { type: "not" }) } } class d extends c { evaluate(e) { return this.evaluateReduce(e, (e, t) => e || t) } validate() { return this.arguments.length > 1 && super.validate() } toJsonReady() { return Object.assign(Object.assign({}, super.toJsonReady()), { type: "or" }) } } class h extends Error { } class m extends h { constructor(e) { super(`Invalid DateTime: ${e.toMessage()}`) } } class f extends h { constructor(e) { super(`Invalid Interval: ${e.toMessage()}`) } } class p extends h { constructor(e) { super(`Invalid Duration: ${e.toMessage()}`) } } class y extends h { } class g extends h { constructor(e) { super(`Invalid unit ${e}`) } } class v extends h { } class $ extends h { constructor() { super("Zone is an abstract class") } } const w = "numeric", b = "short", _ = "long", k = { year: w, month: w, day: w }, S = { year: w, month: b, day: w }, N = { year: w, month: b, day: w, weekday: b }, O = { year: w, month: _, day: w }, E = { year: w, month: _, day: w, weekday: _ }, P = { hour: w, minute: w }, j = { hour: w, minute: w, second: w }, T = { hour: w, minute: w, second: w, timeZoneName: b }, x = { hour: w, minute: w, second: w, timeZoneName: _ }, I = { hour: w, minute: w, hourCycle: "h23" }, M = { hour: w, minute: w, second: w, hourCycle: "h23" }, C = { hour: w, minute: w, second: w, hourCycle: "h23", timeZoneName: b }, D = { hour: w, minute: w, second: w, hourCycle: "h23", timeZoneName: _ }, R = { year: w, month: w, day: w, hour: w, minute: w }, V = { year: w, month: w, day: w, hour: w, minute: w, second: w }, A = { year: w, month: b, day: w, hour: w, minute: w }, z = { year: w, month: b, day: w, hour: w, minute: w, second: w }, F = { year: w, month: b, day: w, weekday: b, hour: w, minute: w }, q = { year: w, month: _, day: w, hour: w, minute: w, timeZoneName: b }, L = { year: w, month: _, day: w, hour: w, minute: w, second: w, timeZoneName: b }, U = { year: w, month: _, day: w, weekday: _, hour: w, minute: w, timeZoneName: _ }, W = { year: w, month: _, day: w, weekday: _, hour: w, minute: w, second: w, timeZoneName: _ }; class Z { get type() { throw new $ } get name() { throw new $ } get ianaName() { return this.name } get isUniversal() { throw new $ } offsetName(e, t) { throw new $ } formatOffset(e, t) { throw new $ } offset(e) { throw new $ } equals(e) { throw new $ } get isValid() { throw new $ } } let J = null; class H extends Z { static get instance() { return null === J && (J = new H), J } get type() { return "system" } get name() { return (new Intl.DateTimeFormat).resolvedOptions().timeZone } get isUniversal() { return !1 } offsetName(e, { format: t, locale: r }) { return mt(e, t, r) } formatOffset(e, t) { return gt(this.offset(e), t) } offset(e) { return -new Date(e).getTimezoneOffset() } equals(e) { return "system" === e.type } get isValid() { return !0 } } const K = new Map; const G = { year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6 }; const Y = new Map; class B extends Z { static create(e) { let t = Y.get(e); return void 0 === t && Y.set(e, t = new B(e)), t } static resetCache() { Y.clear(), K.clear() } static isValidSpecifier(e) { return this.isValidZone(e) } static isValidZone(e) { if (!e) return !1; try { return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0 } catch (e) { return !1 } } constructor(e) { super(), this.zoneName = e, this.valid = B.isValidZone(e) } get type() { return "iana" } get name() { return this.zoneName } get isUniversal() { return !1 } offsetName(e, { format: t, locale: r }) { return mt(e, t, r, this.name) } formatOffset(e, t) { return gt(this.offset(e), t) } offset(e) { if (!this.valid) return NaN; const t = new Date(e); if (isNaN(t)) return NaN; const r = function (e) { let t = K.get(e); return void 0 === t && (t = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: e, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", era: "short" }), K.set(e, t)), t }(this.name); let [s, n, a, o, i, c, u] = r.formatToParts ? function (e, t) { const r = e.formatToParts(t), s = []; for (let e = 0; e < r.length; e++) { const { type: t, value: n } = r[e], a = G[t]; "era" === t ? s[a] = n : Je(a) || (s[a] = parseInt(n, 10)) } return s }(r, t) : function (e, t) { const r = e.format(t).replace(/\u200E/g, ""), s = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(r), [, n, a, o, i, c, u, l] = s; return [o, n, a, i, c, u, l] }(r, t); "BC" === o && (s = 1 - Math.abs(s)); let l = +t; const d = l % 1e3; return l -= d >= 0 ? d : 1e3 + d, (ut({ year: s, month: n, day: a, hour: 24 === i ? 0 : i, minute: c, second: u, millisecond: 0 }) - l) / 6e4 } equals(e) { return "iana" === e.type && e.name === this.name } get isValid() { return this.valid } } let Q = {}; const X = new Map; function ee(e, t = {}) { const r = JSON.stringify([e, t]); let s = X.get(r); return void 0 === s && (s = new Intl.DateTimeFormat(e, t), X.set(r, s)), s } const te = new Map; const re = new Map; let se = null; const ne = new Map; function ae(e) { let t = ne.get(e); return void 0 === t && (t = new Intl.DateTimeFormat(e).resolvedOptions(), ne.set(e, t)), t } const oe = new Map; function ie(e, t, r, s) { const n = e.listingMode(); return "error" === n ? null : "en" === n ? r(t) : s(t) } class ce { constructor(e, t, r) { this.padTo = r.padTo || 0, this.floor = r.floor || !1; const { padTo: s, floor: n, ...a } = r; if (!t || Object.keys(a).length > 0) { const t = { useGrouping: !1, ...r }; r.padTo > 0 && (t.minimumIntegerDigits = r.padTo), this.inf = function (e, t = {}) { const r = JSON.stringify([e, t]); let s = te.get(r); return void 0 === s && (s = new Intl.NumberFormat(e, t), te.set(r, s)), s }(e, t) } } format(e) { if (this.inf) { const t = this.floor ? Math.floor(e) : e; return this.inf.format(t) } return tt(this.floor ? Math.floor(e) : at(e, 3), this.padTo) } } class ue { constructor(e, t, r) { let s; if (this.opts = r, this.originalZone = void 0, this.opts.timeZone) this.dt = e; else if ("fixed" === e.zone.type) { const t = e.offset / 60 * -1, r = t >= 0 ? `Etc/GMT+${t}` : `Etc/GMT${t}`; 0 !== e.offset && B.create(r).valid ? (s = r, this.dt = e) : (s = "UTC", this.dt = 0 === e.offset ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone) } else "system" === e.zone.type ? this.dt = e : "iana" === e.zone.type ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone); const n = { ...this.opts }; n.timeZone = n.timeZone || s, this.dtf = ee(t, n) } format() { return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate()) } formatToParts() { const e = this.dtf.formatToParts(this.dt.toJSDate()); return this.originalZone ? e.map(e => { if ("timeZoneName" === e.type) { const t = this.originalZone.offsetName(this.dt.ts, { locale: this.dt.locale, format: this.opts.timeZoneName }); return { ...e, value: t } } return e }) : e } resolvedOptions() { return this.dtf.resolvedOptions() } } class le { constructor(e, t, r) { this.opts = { style: "long", ...r }, !t && Ge() && (this.rtf = function (e, t = {}) { const { base: r, ...s } = t, n = JSON.stringify([e, s]); let a = re.get(n); return void 0 === a && (a = new Intl.RelativeTimeFormat(e, t), re.set(n, a)), a }(e, r)) } format(e, t) { return this.rtf ? this.rtf.format(e, t) : function (e, t, r = "always", s = !1) { const n = { years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."] }, a = -1 === ["hours", "minutes", "seconds"].indexOf(e); if ("auto" === r && a) { const r = "days" === e; switch (t) { case 1: return r ? "tomorrow" : `next ${n[e][0]}`; case -1: return r ? "yesterday" : `last ${n[e][0]}`; case 0: return r ? "today" : `this ${n[e][0]}` } } const o = Object.is(t, -0) || t < 0, i = Math.abs(t), c = 1 === i, u = n[e], l = s ? c ? u[1] : u[2] || u[1] : c ? n[e][0] : e; return o ? `${i} ${l} ago` : `in ${i} ${l}` }(t, e, this.opts.numeric, "long" !== this.opts.style) } formatToParts(e, t) { return this.rtf ? this.rtf.formatToParts(e, t) : [] } } const de = { firstDay: 1, minimalDays: 4, weekend: [6, 7] }; class he { static fromOpts(e) { return he.create(e.locale, e.numberingSystem, e.outputCalendar, e.weekSettings, e.defaultToEN) } static create(e, t, r, s, n = !1) { const a = e || Te.defaultLocale, o = a || (n ? "en-US" : se || (se = (new Intl.DateTimeFormat).resolvedOptions().locale, se)), i = t || Te.defaultNumberingSystem, c = r || Te.defaultOutputCalendar, u = Xe(s) || Te.defaultWeekSettings; return new he(o, i, c, u, a) } static resetCache() { se = null, X.clear(), te.clear(), re.clear(), ne.clear(), oe.clear() } static fromObject({ locale: e, numberingSystem: t, outputCalendar: r, weekSettings: s } = {}) { return he.create(e, t, r, s) } constructor(e, t, r, s, n) { const [a, o, i] = function (e) { const t = e.indexOf("-x-"); -1 !== t && (e = e.substring(0, t)); const r = e.indexOf("-u-"); if (-1 === r) return [e]; { let t, s; try { t = ee(e).resolvedOptions(), s = e } catch (n) { const a = e.substring(0, r); t = ee(a).resolvedOptions(), s = a } const { numberingSystem: n, calendar: a } = t; return [s, n, a] } }(e); this.locale = a, this.numberingSystem = t || o || null, this.outputCalendar = r || i || null, this.weekSettings = s, this.intl = function (e, t, r) { return r || t ? (e.includes("-u-") || (e += "-u"), r && (e += `-ca-${r}`), t && (e += `-nu-${t}`), e) : e }(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = n, this.fastNumbersCached = null } get fastNumbers() { var e; return null == this.fastNumbersCached && (this.fastNumbersCached = (!(e = this).numberingSystem || "latn" === e.numberingSystem) && ("latn" === e.numberingSystem || !e.locale || e.locale.startsWith("en") || "latn" === ae(e.locale).numberingSystem)), this.fastNumbersCached } listingMode() { const e = this.isEnglish(), t = !(null !== this.numberingSystem && "latn" !== this.numberingSystem || null !== this.outputCalendar && "gregory" !== this.outputCalendar); return e && t ? "en" : "intl" } clone(e) { return e && 0 !== Object.getOwnPropertyNames(e).length ? he.create(e.locale || this.specifiedLocale, e.numberingSystem || this.numberingSystem, e.outputCalendar || this.outputCalendar, Xe(e.weekSettings) || this.weekSettings, e.defaultToEN || !1) : this } redefaultToEN(e = {}) { return this.clone({ ...e, defaultToEN: !0 }) } redefaultToSystem(e = {}) { return this.clone({ ...e, defaultToEN: !1 }) } months(e, t = !1) { return ie(this, e, _t, () => { const r = "ja" === this.intl || this.intl.startsWith("ja-"), s = (t &= !r) ? { month: e, day: "numeric" } : { month: e }, n = t ? "format" : "standalone"; if (!this.monthsCache[n][e]) { const t = r ? e => this.dtFormatter(e, s).format() : e => this.extract(e, s, "month"); this.monthsCache[n][e] = function (e) { const t = []; for (let r = 1; r <= 12; r++) { const s = Es.utc(2009, r, 1); t.push(e(s)) } return t }(t) } return this.monthsCache[n][e] }) } weekdays(e, t = !1) { return ie(this, e, Ot, () => { const r = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = t ? "format" : "standalone"; return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = function (e) { const t = []; for (let r = 1; r <= 7; r++) { const s = Es.utc(2016, 11, 13 + r); t.push(e(s)) } return t }(e => this.extract(e, r, "weekday"))), this.weekdaysCache[s][e] }) } meridiems() { return ie(this, void 0, () => Et, () => { if (!this.meridiemCache) { const e = { hour: "numeric", hourCycle: "h12" }; this.meridiemCache = [Es.utc(2016, 11, 13, 9), Es.utc(2016, 11, 13, 19)].map(t => this.extract(t, e, "dayperiod")) } return this.meridiemCache }) } eras(e) { return ie(this, e, xt, () => { const t = { era: e }; return this.eraCache[e] || (this.eraCache[e] = [Es.utc(-40, 1, 1), Es.utc(2017, 1, 1)].map(e => this.extract(e, t, "era"))), this.eraCache[e] }) } extract(e, t, r) { const s = this.dtFormatter(e, t).formatToParts().find(e => e.type.toLowerCase() === r); return s ? s.value : null } numberFormatter(e = {}) { return new ce(this.intl, e.forceSimple || this.fastNumbers, e) } dtFormatter(e, t = {}) { return new ue(e, this.intl, t) } relFormatter(e = {}) { return new le(this.intl, this.isEnglish(), e) } listFormatter(e = {}) { return function (e, t = {}) { const r = JSON.stringify([e, t]); let s = Q[r]; return s || (s = new Intl.ListFormat(e, t), Q[r] = s), s }(this.intl, e) } isEnglish() { return "en" === this.locale || "en-us" === this.locale.toLowerCase() || ae(this.intl).locale.startsWith("en-us") } getWeekSettings() { return this.weekSettings ? this.weekSettings : Ye() ? function (e) { let t = oe.get(e); if (!t) { const r = new Intl.Locale(e); t = "getWeekInfo" in r ? r.getWeekInfo() : r.weekInfo, "minimalDays" in t || (t = { ...de, ...t }), oe.set(e, t) } return t }(this.locale) : de } getStartOfWeek() { return this.getWeekSettings().firstDay } getMinDaysInFirstWeek() { return this.getWeekSettings().minimalDays } getWeekendDays() { return this.getWeekSettings().weekend } equals(e) { return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar } toString() { return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})` } } let me = null; class fe extends Z { static get utcInstance() { return null === me && (me = new fe(0)), me } static instance(e) { return 0 === e ? fe.utcInstance : new fe(e) } static parseSpecifier(e) { if (e) { const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i); if (t) return new fe(ft(t[1], t[2])) } return null } constructor(e) { super(), this.fixed = e } get type() { return "fixed" } get name() { return 0 === this.fixed ? "UTC" : `UTC${gt(this.fixed, "narrow")}` } get ianaName() { return 0 === this.fixed ? "Etc/UTC" : `Etc/GMT${gt(-this.fixed, "narrow")}` } offsetName() { return this.name } formatOffset(e, t) { return gt(this.fixed, t) } get isUniversal() { return !0 } offset() { return this.fixed } equals(e) { return "fixed" === e.type && e.fixed === this.fixed } get isValid() { return !0 } } class pe extends Z { constructor(e) { super(), this.zoneName = e } get type() { return "invalid" } get name() { return this.zoneName } get isUniversal() { return !1 } offsetName() { return null } formatOffset() { return "" } offset() { return NaN } equals() { return !1 } get isValid() { return !1 } } function ye(e, t) { if (Je(e) || null === e) return t; if (e instanceof Z) return e; if ("string" == typeof e) { const r = e.toLowerCase(); return "default" === r ? t : "local" === r || "system" === r ? H.instance : "utc" === r || "gmt" === r ? fe.utcInstance : fe.parseSpecifier(r) || B.create(e) } return He(e) ? fe.instance(e) : "object" == typeof e && "offset" in e && "function" == typeof e.offset ? e : new pe(e) } const ge = { arab: "[-]", arabext: "[-]", bali: "[-]", beng: "[-]", deva: "[-]", fullwide: "[-]", gujr: "[-]", hanidec: "[|||||||||]", khmr: "[-]", knda: "[-]", laoo: "[-]", limb: "[-]", mlym: "[-]", mong: "[-]", mymr: "[-]", orya: "[-]", tamldec: "[-]", telu: "[-]", thai: "[-]", tibt: "[-]", latn: "\\d" }, ve = { arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430, 3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881] }, $e = ge.hanidec.replace(/[\[|\]]/g, "").split(""); const we = new Map; function be({ numberingSystem: e }, t = "") { const r = e || "latn"; let s = we.get(r); void 0 === s && (s = new Map, we.set(r, s)); let n = s.get(t); return void 0 === n && (n = new RegExp(`${ge[r]}${t}`), s.set(t, n)), n } let _e, ke = () => Date.now(), Se = "system", Ne = null, Oe = null, Ee = null, Pe = 60, je = null; class Te { static get now() { return ke } static set now(e) { ke = e } static set defaultZone(e) { Se = e } static get defaultZone() { return ye(Se, H.instance) } static get defaultLocale() { return Ne } static set defaultLocale(e) { Ne = e } static get defaultNumberingSystem() { return Oe } static set defaultNumberingSystem(e) { Oe = e } static get defaultOutputCalendar() { return Ee } static set defaultOutputCalendar(e) { Ee = e } static get defaultWeekSettings() { return je } static set defaultWeekSettings(e) { je = Xe(e) } static get twoDigitCutoffYear() { return Pe } static set twoDigitCutoffYear(e) { Pe = e % 100 } static get throwOnInvalid() { return _e } static set throwOnInvalid(e) { _e = e } static resetCaches() { he.resetCache(), B.resetCache(), Es.resetCache(), we.clear() } } class xe { constructor(e, t) { this.reason = e, this.explanation = t } toMessage() { return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason } } const Ie = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Me = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]; function Ce(e, t) { return new xe("unit out of range", `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`) } function De(e, t, r) { const s = new Date(Date.UTC(e, t - 1, r)); e < 100 && e >= 0 && s.setUTCFullYear(s.getUTCFullYear() - 1900); const n = s.getUTCDay(); return 0 === n ? 7 : n } function Re(e, t, r) { return r + (ot(e) ? Me : Ie)[t - 1] } function Ve(e, t) { const r = ot(e) ? Me : Ie, s = r.findIndex(e => e < t); return { month: s + 1, day: t - r[s] } } function Ae(e, t) { return (e - t + 7) % 7 + 1 } function ze(e, t = 4, r = 1) { const { year: s, month: n, day: a } = e, o = Re(s, n, a), i = Ae(De(s, n, a), r); let c, u = Math.floor((o - i + 14 - t) / 7); return u < 1 ? (c = s - 1, u = dt(c, t, r)) : u > dt(s, t, r) ? (c = s + 1, u = 1) : c = s, { weekYear: c, weekNumber: u, weekday: i, ...vt(e) } } function Fe(e, t = 4, r = 1) { const { weekYear: s, weekNumber: n, weekday: a } = e, o = Ae(De(s, 1, t), r), i = it(s); let c, u = 7 * n + a - o - 7 + t; u < 1 ? (c = s - 1, u += it(c)) : u > i ? (c = s + 1, u -= it(s)) : c = s; const { month: l, day: d } = Ve(c, u); return { year: c, month: l, day: d, ...vt(e) } } function qe(e) { const { year: t, month: r, day: s } = e; return { year: t, ordinal: Re(t, r, s), ...vt(e) } } function Le(e) { const { year: t, ordinal: r } = e, { month: s, day: n } = Ve(t, r); return { year: t, month: s, day: n, ...vt(e) } } function Ue(e, t) { if (!Je(e.localWeekday) || !Je(e.localWeekNumber) || !Je(e.localWeekYear)) { if (!Je(e.weekday) || !Je(e.weekNumber) || !Je(e.weekYear)) throw new y("Cannot mix locale-based week fields with ISO-based week fields"); return Je(e.localWeekday) || (e.weekday = e.localWeekday), Je(e.localWeekNumber) || (e.weekNumber = e.localWeekNumber), Je(e.localWeekYear) || (e.weekYear = e.localWeekYear), delete e.localWeekday, delete e.localWeekNumber, delete e.localWeekYear, { minDaysInFirstWeek: t.getMinDaysInFirstWeek(), startOfWeek: t.getStartOfWeek() } } return { minDaysInFirstWeek: 4, startOfWeek: 1 } } function We(e) { const t = Ke(e.year), r = et(e.month, 1, 12), s = et(e.day, 1, ct(e.year, e.month)); return t ? r ? !s && Ce("day", e.day) : Ce("month", e.month) : Ce("year", e.year) } function Ze(e) { const { hour: t, minute: r, second: s, millisecond: n } = e, a = et(t, 0, 23) || 24 === t && 0 === r && 0 === s && 0 === n, o = et(r, 0, 59), i = et(s, 0, 59), c = et(n, 0, 999); return a ? o ? i ? !c && Ce("millisecond", n) : Ce("second", s) : Ce("minute", r) : Ce("hour", t) } function Je(e) { return void 0 === e } function He(e) { return "number" == typeof e } function Ke(e) { return "number" == typeof e && e % 1 == 0 } function Ge() { try { return "undefined" != typeof Intl && !!Intl.RelativeTimeFormat } catch (e) { return !1 } } function Ye() { try { return "undefined" != typeof Intl && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype) } catch (e) { return !1 } } function Be(e, t, r) { if (0 !== e.length) return e.reduce((e, s) => { const n = [t(s), s]; return e && r(e[0], n[0]) === e[0] ? e : n }, null)[1] } function Qe(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function Xe(e) { if (null == e) return null; if ("object" != typeof e) throw new v("Week settings must be an object"); if (!et(e.firstDay, 1, 7) || !et(e.minimalDays, 1, 7) || !Array.isArray(e.weekend) || e.weekend.some(e => !et(e, 1, 7))) throw new v("Invalid week settings"); return { firstDay: e.firstDay, minimalDays: e.minimalDays, weekend: Array.from(e.weekend) } } function et(e, t, r) { return Ke(e) && e >= t && e <= r } function tt(e, t = 2) { let r; return r = e < 0 ? "-" + ("" + -e).padStart(t, "0") : ("" + e).padStart(t, "0"), r } function rt(e) { return Je(e) || null === e || "" === e ? void 0 : parseInt(e, 10) } function st(e) { return Je(e) || null === e || "" === e ? void 0 : parseFloat(e) } function nt(e) { if (!Je(e) && null !== e && "" !== e) { const t = 1e3 * parseFloat("0." + e); return Math.floor(t) } } function at(e, t, r = "round") { const s = 10 ** t; switch (r) { case "expand": return e > 0 ? Math.ceil(e * s) / s : Math.floor(e * s) / s; case "trunc": return Math.trunc(e * s) / s; case "round": return Math.round(e * s) / s; case "floor": return Math.floor(e * s) / s; case "ceil": return Math.ceil(e * s) / s; default: throw new RangeError(`Value rounding ${r} is out of range`) } } function ot(e) { return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0) } function it(e) { return ot(e) ? 366 : 365 } function ct(e, t) { const r = function (e, t) { return e - t * Math.floor(e / t) }(t - 1, 12) + 1; return 2 === r ? ot(e + (t - r) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r - 1] } function ut(e) { let t = Date.UTC(e.year, e.month - 1, e.day, e.hour, e.minute, e.second, e.millisecond); return e.year < 100 && e.year >= 0 && (t = new Date(t), t.setUTCFullYear(e.year, e.month - 1, e.day)), +t } function lt(e, t, r) { return -Ae(De(e, 1, t), r) + t - 1 } function dt(e, t = 4, r = 1) { const s = lt(e, t, r), n = lt(e + 1, t, r); return (it(e) - s + n) / 7 } function ht(e) { return e > 99 ? e : e > Te.twoDigitCutoffYear ? 1900 + e : 2e3 + e } function mt(e, t, r, s = null) { const n = new Date(e), a = { hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" }; s && (a.timeZone = s); const o = { timeZoneName: t, ...a }, i = new Intl.DateTimeFormat(r, o).formatToParts(n).find(e => "timezonename" === e.type.toLowerCase()); return i ? i.value : null } function ft(e, t) { let r = parseInt(e, 10); Number.isNaN(r) && (r = 0); const s = parseInt(t, 10) || 0; return 60 * r + (r < 0 || Object.is(r, -0) ? -s : s) } function pt(e) { const t = Number(e); if ("boolean" == typeof e || "" === e || !Number.isFinite(t)) throw new v(`Invalid unit value ${e}`); return t } function yt(e, t) { const r = {}; for (const s in e) if (Qe(e, s)) { const n = e[s]; if (null == n) continue; r[t(s)] = pt(n) } return r } function gt(e, t) { const r = Math.trunc(Math.abs(e / 60)), s = Math.trunc(Math.abs(e % 60)), n = e >= 0 ? "+" : "-"; switch (t) { case "short": return `${n}${tt(r, 2)}:${tt(s, 2)}`; case "narrow": return `${n}${r}${s > 0 ? `:${s}` : ""}`; case "techie": return `${n}${tt(r, 2)}${tt(s, 2)}`; default: throw new RangeError(`Value format ${t} is out of range for property format`) } } function vt(e) { return function (e, t) { return t.reduce((t, r) => (t[r] = e[r], t), {}) }(e, ["hour", "minute", "second", "millisecond"]) } const $t = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], wt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], bt = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]; function _t(e) { switch (e) { case "narrow": return [...bt]; case "short": return [...wt]; case "long": return [...$t]; case "numeric": return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]; case "2-digit": return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"]; default: return null } } const kt = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], St = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], Nt = ["M", "T", "W", "T", "F", "S", "S"]; function Ot(e) { switch (e) { case "narrow": return [...Nt]; case "short": return [...St]; case "long": return [...kt]; case "numeric": return ["1", "2", "3", "4", "5", "6", "7"]; default: return null } } const Et = ["AM", "PM"], Pt = ["Before Christ", "Anno Domini"], jt = ["BC", "AD"], Tt = ["B", "A"]; function xt(e) { switch (e) { case "narrow": return [...Tt]; case "short": return [...jt]; case "long": return [...Pt]; default: return null } } function It(e, t) { let r = ""; for (const s of e) s.literal ? r += s.val : r += t(s.val); return r } const Mt = { D: k, DD: S, DDD: O, DDDD: E, t: P, tt: j, ttt: T, tttt: x, T: I, TT: M, TTT: C, TTTT: D, f: R, ff: A, fff: q, ffff: U, F: V, FF: z, FFF: L, FFFF: W }; class Ct { static create(e, t = {}) { return new Ct(e, t) } static parseFormat(e) { let t = null, r = "", s = !1; const n = []; for (let a = 0; a < e.length; a++) { const o = e.charAt(a); "'" === o ? ((r.length > 0 || s) && n.push({ literal: s || /^\s+$/.test(r), val: "" === r ? "'" : r }), t = null, r = "", s = !s) : s || o === t ? r += o : (r.length > 0 && n.push({ literal: /^\s+$/.test(r), val: r }), r = o, t = o) } return r.length > 0 && n.push({ literal: s || /^\s+$/.test(r), val: r }), n } static macroTokenToFormatOpts(e) { return Mt[e] } constructor(e, t) { this.opts = t, this.loc = e, this.systemLoc = null } formatWithSystemDefault(e, t) { null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem()); return this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format() } dtFormatter(e, t = {}) { return this.loc.dtFormatter(e, { ...this.opts, ...t }) } formatDateTime(e, t) { return this.dtFormatter(e, t).format() } formatDateTimeParts(e, t) { return this.dtFormatter(e, t).formatToParts() } formatInterval(e, t) { return this.dtFormatter(e.start, t).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate()) } resolvedOptions(e, t) { return this.dtFormatter(e, t).resolvedOptions() } num(e, t = 0, r = void 0) { if (this.opts.forceSimple) return tt(e, t); const s = { ...this.opts }; return t > 0 && (s.padTo = t), r && (s.signDisplay = r), this.loc.numberFormatter(s).format(e) } formatDateTimeFromString(e, t) { const r = "en" === this.loc.listingMode(), s = this.loc.outputCalendar && "gregory" !== this.loc.outputCalendar, n = (t, r) => this.loc.extract(e, t, r), a = t => e.isOffsetFixed && 0 === e.offset && t.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, t.format) : "", o = () => r ? function (e) { return Et[e.hour < 12 ? 0 : 1] }(e) : n({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), i = (t, s) => r ? function (e, t) { return _t(t)[e.month - 1] }(e, t) : n(s ? { month: t } : { month: t, day: "numeric" }, "month"), c = (t, s) => r ? function (e, t) { return Ot(t)[e.weekday - 1] }(e, t) : n(s ? { weekday: t } : { weekday: t, month: "long", day: "numeric" }, "weekday"), u = t => { const r = Ct.macroTokenToFormatOpts(t); return r ? this.formatWithSystemDefault(e, r) : t }, l = t => r ? function (e, t) { return xt(t)[e.year < 0 ? 0 : 1] }(e, t) : n({ era: t }, "era"); return It(Ct.parseFormat(t), t => { switch (t) { case "S": return this.num(e.millisecond); case "u": case "SSS": return this.num(e.millisecond, 3); case "s": return this.num(e.second); case "ss": return this.num(e.second, 2); case "uu": return this.num(Math.floor(e.millisecond / 10), 2); case "uuu": return this.num(Math.floor(e.millisecond / 100)); case "m": return this.num(e.minute); case "mm": return this.num(e.minute, 2); case "h": return this.num(e.hour % 12 == 0 ? 12 : e.hour % 12); case "hh": return this.num(e.hour % 12 == 0 ? 12 : e.hour % 12, 2); case "H": return this.num(e.hour); case "HH": return this.num(e.hour, 2); case "Z": return a({ format: "narrow", allowZ: this.opts.allowZ }); case "ZZ": return a({ format: "short", allowZ: this.opts.allowZ }); case "ZZZ": return a({ format: "techie", allowZ: this.opts.allowZ }); case "ZZZZ": return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale }); case "ZZZZZ": return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale }); case "z": return e.zoneName; case "a": return o(); case "d": return s ? n({ day: "numeric" }, "day") : this.num(e.day); case "dd": return s ? n({ day: "2-digit" }, "day") : this.num(e.day, 2); case "c": case "E": return this.num(e.weekday); case "ccc": return c("short", !0); case "cccc": return c("long", !0); case "ccccc": return c("narrow", !0); case "EEE": return c("short", !1); case "EEEE": return c("long", !1); case "EEEEE": return c("narrow", !1); case "L": return s ? n({ month: "numeric", day: "numeric" }, "month") : this.num(e.month); case "LL": return s ? n({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2); case "LLL": return i("short", !0); case "LLLL": return i("long", !0); case "LLLLL": return i("narrow", !0); case "M": return s ? n({ month: "numeric" }, "month") : this.num(e.month); case "MM": return s ? n({ month: "2-digit" }, "month") : this.num(e.month, 2); case "MMM": return i("short", !1); case "MMMM": return i("long", !1); case "MMMMM": return i("narrow", !1); case "y": return s ? n({ year: "numeric" }, "year") : this.num(e.year); case "yy": return s ? n({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2); case "yyyy": return s ? n({ year: "numeric" }, "year") : this.num(e.year, 4); case "yyyyyy": return s ? n({ year: "numeric" }, "year") : this.num(e.year, 6); case "G": return l("short"); case "GG": return l("long"); case "GGGGG": return l("narrow"); case "kk": return this.num(e.weekYear.toString().slice(-2), 2); case "kkkk": return this.num(e.weekYear, 4); case "W": return this.num(e.weekNumber); case "WW": return this.num(e.weekNumber, 2); case "n": return this.num(e.localWeekNumber); case "nn": return this.num(e.localWeekNumber, 2); case "ii": return this.num(e.localWeekYear.toString().slice(-2), 2); case "iiii": return this.num(e.localWeekYear, 4); case "o": return this.num(e.ordinal); case "ooo": return this.num(e.ordinal, 3); case "q": return this.num(e.quarter); case "qq": return this.num(e.quarter, 2); case "X": return this.num(Math.floor(e.ts / 1e3)); case "x": return this.num(e.ts); default: return u(t) } }) } formatDurationFromString(e, t) { const r = "negativeLargestOnly" === this.opts.signMode ? -1 : 1, s = e => { switch (e[0]) { case "S": return "milliseconds"; case "s": return "seconds"; case "m": return "minutes"; case "h": return "hours"; case "d": return "days"; case "w": return "weeks"; case "M": return "months"; case "y": return "years"; default: return null } }, n = Ct.parseFormat(t), a = n.reduce((e, { literal: t, val: r }) => t ? e : e.concat(r), []), o = e.shiftTo(...a.map(s).filter(e => e)); return It(n, ((e, t) => n => { const a = s(n); if (a) { const s = t.isNegativeDuration && a !== t.largestUnit ? r : 1; let o; return o = "negativeLargestOnly" === this.opts.signMode && a !== t.largestUnit ? "never" : "all" === this.opts.signMode ? "always" : "auto", this.num(e.get(a) * s, n.length, o) } return n })(o, { isNegativeDuration: o < 0, largestUnit: Object.keys(o.values)[0] })) } } const Dt = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/; function Rt(...e) { const t = e.reduce((e, t) => e + t.source, ""); return RegExp(`^${t}$`) } function Vt(...e) { return t => e.reduce(([e, r, s], n) => { const [a, o, i] = n(t, s); return [{ ...e, ...a }, o || r, i] }, [{}, null, 1]).slice(0, 2) } function At(e, ...t) { if (null == e) return [null, null]; for (const [r, s] of t) { const t = r.exec(e); if (t) return s(t) } return [null, null] } function zt(...e) { return (t, r) => { const s = {}; let n; for (n = 0; n < e.length; n++)s[e[n]] = rt(t[r + n]); return [s, null, r + n] } } const Ft = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/, qt = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Lt = RegExp(`${qt.source}${`(?:${Ft.source}?(?:\\[(${Dt.source})\\])?)?`}`), Ut = RegExp(`(?:[Tt]${Lt.source})?`), Wt = zt("weekYear", "weekNumber", "weekDay"), Zt = zt("year", "ordinal"), Jt = RegExp(`${qt.source} ?(?:${Ft.source}|(${Dt.source}))?`), Ht = RegExp(`(?: ${Jt.source})?`); function Kt(e, t, r) { const s = e[t]; return Je(s) ? r : rt(s) } function Gt(e, t) { return [{ hours: Kt(e, t, 0), minutes: Kt(e, t + 1, 0), seconds: Kt(e, t + 2, 0), milliseconds: nt(e[t + 3]) }, null, t + 4] } function Yt(e, t) { const r = !e[t] && !e[t + 1], s = ft(e[t + 1], e[t + 2]); return [{}, r ? null : fe.instance(s), t + 3] } function Bt(e, t) { return [{}, e[t] ? B.create(e[t]) : null, t + 1] } const Qt = RegExp(`^T?${qt.source}$`), Xt = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/; function er(e) { const [t, r, s, n, a, o, i, c, u] = e, l = "-" === t[0], d = c && "-" === c[0], h = (e, t = !1) => void 0 !== e && (t || e && l) ? -e : e; return [{ years: h(st(r)), months: h(st(s)), weeks: h(st(n)), days: h(st(a)), hours: h(st(o)), minutes: h(st(i)), seconds: h(st(c), "-0" === c), milliseconds: h(nt(u), d) }] } const tr = { GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 }; function rr(e, t, r, s, n, a, o) { const i = { year: 2 === t.length ? ht(rt(t)) : rt(t), month: wt.indexOf(r) + 1, day: rt(s), hour: rt(n), minute: rt(a) }; return o && (i.second = rt(o)), e && (i.weekday = e.length > 3 ? kt.indexOf(e) + 1 : St.indexOf(e) + 1), i } const sr = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/; function nr(e) { const [, t, r, s, n, a, o, i, c, u, l, d] = e, h = rr(t, n, s, r, a, o, i); let m; return m = c ? tr[c] : u ? 0 : ft(l, d), [h, new fe(m)] } const ar = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, or = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ir = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/; function cr(e) { const [, t, r, s, n, a, o, i] = e; return [rr(t, n, s, r, a, o, i), fe.utcInstance] } function ur(e) { const [, t, r, s, n, a, o, i] = e; return [rr(t, i, r, s, n, a, o), fe.utcInstance] } const lr = Rt(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, Ut), dr = Rt(/(\d{4})-?W(\d\d)(?:-?(\d))?/, Ut), hr = Rt(/(\d{4})-?(\d{3})/, Ut), mr = Rt(Lt), fr = Vt(function (e, t) { return [{ year: Kt(e, t), month: Kt(e, t + 1, 1), day: Kt(e, t + 2, 1) }, null, t + 3] }, Gt, Yt, Bt), pr = Vt(Wt, Gt, Yt, Bt), yr = Vt(Zt, Gt, Yt, Bt), gr = Vt(Gt, Yt, Bt); const vr = Vt(Gt); const $r = Rt(/(\d{4})-(\d\d)-(\d\d)/, Ht), wr = Rt(Jt), br = Vt(Gt, Yt, Bt); const _r = "Invalid Duration", kr = { weeks: { days: 7, hours: 168, minutes: 10080, seconds: 604800, milliseconds: 6048e5 }, days: { hours: 24, minutes: 1440, seconds: 86400, milliseconds: 864e5 }, hours: { minutes: 60, seconds: 3600, milliseconds: 36e5 }, minutes: { seconds: 60, milliseconds: 6e4 }, seconds: { milliseconds: 1e3 } }, Sr = { years: { quarters: 4, months: 12, weeks: 52, days: 365, hours: 8760, minutes: 525600, seconds: 31536e3, milliseconds: 31536e6 }, quarters: { months: 3, weeks: 13, days: 91, hours: 2184, minutes: 131040, seconds: 7862400, milliseconds: 78624e5 }, months: { weeks: 4, days: 30, hours: 720, minutes: 43200, seconds: 2592e3, milliseconds: 2592e6 }, ...kr }, Nr = 365.2425, Or = 30.436875, Er = { years: { quarters: 4, months: 12, weeks: 52.1775, days: Nr, hours: 8765.82, minutes: 525949.2, seconds: 525949.2 * 60, milliseconds: 525949.2 * 60 * 1e3 }, quarters: { months: 3, weeks: 13.044375, days: 91.310625, hours: 2191.455, minutes: 131487.3, seconds: 525949.2 * 60 / 4, milliseconds: 7889237999.999999 }, months: { weeks: 4.3481250000000005, days: Or, hours: 730.485, minutes: 43829.1, seconds: 2629746, milliseconds: 2629746e3 }, ...kr }, Pr = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], jr = Pr.slice(0).reverse(); function Tr(e, t, r = !1) { const s = { values: r ? t.values : { ...e.values, ...t.values || {} }, loc: e.loc.clone(t.loc), conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy, matrix: t.matrix || e.matrix }; return new Cr(s) } function xr(e, t) { let r = t.milliseconds ?? 0; for (const s of jr.slice(1)) t[s] && (r += t[s] * e[s].milliseconds); return r } function Ir(e, t) { const r = xr(e, t) < 0 ? -1 : 1; Pr.reduceRight((s, n) => { if (Je(t[n])) return s; if (s) { const a = t[s] * r, o = e[n][s], i = Math.floor(a / o); t[n] += i * r, t[s] -= i * o * r } return n }, null), Pr.reduce((r, s) => { if (Je(t[s])) return r; if (r) { const n = t[r] % 1; t[r] -= n, t[s] += n * e[r][s] } return s }, null) } function Mr(e) { const t = {}; for (const [r, s] of Object.entries(e)) 0 !== s && (t[r] = s); return t } class Cr { constructor(e) { const t = "longterm" === e.conversionAccuracy || !1; let r = t ? Er : Sr; e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || he.create(), this.conversionAccuracy = t ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0 } static fromMillis(e, t) { return Cr.fromObject({ milliseconds: e }, t) } static fromObject(e, t = {}) { if (null == e || "object" != typeof e) throw new v("Duration.fromObject: argument expected to be an object, got " + (null === e ? "null" : typeof e)); return new Cr({ values: yt(e, Cr.normalizeUnit), loc: he.fromObject(t), conversionAccuracy: t.conversionAccuracy, matrix: t.matrix }) } static fromDurationLike(e) { if (He(e)) return Cr.fromMillis(e); if (Cr.isDuration(e)) return e; if ("object" == typeof e) return Cr.fromObject(e); throw new v(`Unknown duration argument ${e} of type ${typeof e}`) } static fromISO(e, t) { const [r] = function (e) { return At(e, [Xt, er]) }(e); return r ? Cr.fromObject(r, t) : Cr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`) } static fromISOTime(e, t) { const [r] = function (e) { return At(e, [Qt, vr]) }(e); return r ? Cr.fromObject(r, t) : Cr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`) } static invalid(e, t = null) { if (!e) throw new v("need to specify a reason the Duration is invalid"); const r = e instanceof xe ? e : new xe(e, t); if (Te.throwOnInvalid) throw new p(r); return new Cr({ invalid: r }) } static normalizeUnit(e) { const t = { year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds" }[e ? e.toLowerCase() : e]; if (!t) throw new g(e); return t } static isDuration(e) { return e && e.isLuxonDuration || !1 } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } toFormat(e, t = {}) { const r = { ...t, floor: !1 !== t.round && !1 !== t.floor }; return this.isValid ? Ct.create(this.loc, r).formatDurationFromString(this, e) : _r } toHuman(e = {}) { if (!this.isValid) return _r; const t = !1 !== e.showZeros, r = Pr.map(r => { const s = this.values[r]; return Je(s) || 0 === s && !t ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: r.slice(0, -1) }).format(s) }).filter(e => e); return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(r) } toObject() { return this.isValid ? { ...this.values } : {} } toISO() { if (!this.isValid) return null; let e = "P"; return 0 !== this.years && (e += this.years + "Y"), 0 === this.months && 0 === this.quarters || (e += this.months + 3 * this.quarters + "M"), 0 !== this.weeks && (e += this.weeks + "W"), 0 !== this.days && (e += this.days + "D"), 0 === this.hours && 0 === this.minutes && 0 === this.seconds && 0 === this.milliseconds || (e += "T"), 0 !== this.hours && (e += this.hours + "H"), 0 !== this.minutes && (e += this.minutes + "M"), 0 === this.seconds && 0 === this.milliseconds || (e += at(this.seconds + this.milliseconds / 1e3, 3) + "S"), "P" === e && (e += "T0S"), e } toISOTime(e = {}) { if (!this.isValid) return null; const t = this.toMillis(); if (t < 0 || t >= 864e5) return null; e = { suppressMilliseconds: !1, suppressSeconds: !1, includePrefix: !1, format: "extended", ...e, includeOffset: !1 }; return Es.fromMillis(t, { zone: "UTC" }).toISOTime(e) } toJSON() { return this.toISO() } toString() { return this.toISO() } [Symbol.for("nodejs.util.inspect.custom")]() { return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }` } toMillis() { return this.isValid ? xr(this.matrix, this.values) : NaN } valueOf() { return this.toMillis() } plus(e) { if (!this.isValid) return this; const t = Cr.fromDurationLike(e), r = {}; for (const e of Pr) (Qe(t.values, e) || Qe(this.values, e)) && (r[e] = t.get(e) + this.get(e)); return Tr(this, { values: r }, !0) } minus(e) { if (!this.isValid) return this; const t = Cr.fromDurationLike(e); return this.plus(t.negate()) } mapUnits(e) { if (!this.isValid) return this; const t = {}; for (const r of Object.keys(this.values)) t[r] = pt(e(this.values[r], r)); return Tr(this, { values: t }, !0) } get(e) { return this[Cr.normalizeUnit(e)] } set(e) { if (!this.isValid) return this; return Tr(this, { values: { ...this.values, ...yt(e, Cr.normalizeUnit) } }) } reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: r, matrix: s } = {}) { return Tr(this, { loc: this.loc.clone({ locale: e, numberingSystem: t }), matrix: s, conversionAccuracy: r }) } as(e) { return this.isValid ? this.shiftTo(e).get(e) : NaN } normalize() { if (!this.isValid) return this; const e = this.toObject(); return Ir(this.matrix, e), Tr(this, { values: e }, !0) } rescale() { if (!this.isValid) return this; return Tr(this, { values: Mr(this.normalize().shiftToAll().toObject()) }, !0) } shiftTo(...e) { if (!this.isValid) return this; if (0 === e.length) return this; e = e.map(e => Cr.normalizeUnit(e)); const t = {}, r = {}, s = this.toObject(); let n; for (const a of Pr) if (e.indexOf(a) >= 0) { n = a; let e = 0; for (const t in r) e += this.matrix[t][a] * r[t], r[t] = 0; He(s[a]) && (e += s[a]); const o = Math.trunc(e); t[a] = o, r[a] = (1e3 * e - 1e3 * o) / 1e3 } else He(s[a]) && (r[a] = s[a]); for (const e in r) 0 !== r[e] && (t[n] += e === n ? r[e] : r[e] / this.matrix[n][e]); return Ir(this.matrix, t), Tr(this, { values: t }, !0) } shiftToAll() { return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this } negate() { if (!this.isValid) return this; const e = {}; for (const t of Object.keys(this.values)) e[t] = 0 === this.values[t] ? 0 : -this.values[t]; return Tr(this, { values: e }, !0) } removeZeros() { if (!this.isValid) return this; return Tr(this, { values: Mr(this.values) }, !0) } get years() { return this.isValid ? this.values.years || 0 : NaN } get quarters() { return this.isValid ? this.values.quarters || 0 : NaN } get months() { return this.isValid ? this.values.months || 0 : NaN } get weeks() { return this.isValid ? this.values.weeks || 0 : NaN } get days() { return this.isValid ? this.values.days || 0 : NaN } get hours() { return this.isValid ? this.values.hours || 0 : NaN } get minutes() { return this.isValid ? this.values.minutes || 0 : NaN } get seconds() { return this.isValid ? this.values.seconds || 0 : NaN } get milliseconds() { return this.isValid ? this.values.milliseconds || 0 : NaN } get isValid() { return null === this.invalid } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } equals(e) { if (!this.isValid || !e.isValid) return !1; if (!this.loc.equals(e.loc)) return !1; function t(e, t) { return void 0 === e || 0 === e ? void 0 === t || 0 === t : e === t } for (const r of Pr) if (!t(this.values[r], e.values[r])) return !1; return !0 } } const Dr = "Invalid Interval"; class Rr { constructor(e) { this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0 } static invalid(e, t = null) { if (!e) throw new v("need to specify a reason the Interval is invalid"); const r = e instanceof xe ? e : new xe(e, t); if (Te.throwOnInvalid) throw new f(r); return new Rr({ invalid: r }) } static fromDateTimes(e, t) { const r = Ps(e), s = Ps(t), n = function (e, t) { return e && e.isValid ? t && t.isValid ? t < e ? Rr.invalid("end before start", `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`) : null : Rr.invalid("missing or invalid end") : Rr.invalid("missing or invalid start") }(r, s); return null == n ? new Rr({ start: r, end: s }) : n } static after(e, t) { const r = Cr.fromDurationLike(t), s = Ps(e); return Rr.fromDateTimes(s, s.plus(r)) } static before(e, t) { const r = Cr.fromDurationLike(t), s = Ps(e); return Rr.fromDateTimes(s.minus(r), s) } static fromISO(e, t) { const [r, s] = (e || "").split("/", 2); if (r && s) { let e, n, a, o; try { e = Es.fromISO(r, t), n = e.isValid } catch (s) { n = !1 } try { a = Es.fromISO(s, t), o = a.isValid } catch (s) { o = !1 } if (n && o) return Rr.fromDateTimes(e, a); if (n) { const r = Cr.fromISO(s, t); if (r.isValid) return Rr.after(e, r) } else if (o) { const e = Cr.fromISO(r, t); if (e.isValid) return Rr.before(a, e) } } return Rr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`) } static isInterval(e) { return e && e.isLuxonInterval || !1 } get start() { return this.isValid ? this.s : null } get end() { return this.isValid ? this.e : null } get lastDateTime() { return this.isValid && this.e ? this.e.minus(1) : null } get isValid() { return null === this.invalidReason } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } length(e = "milliseconds") { return this.isValid ? this.toDuration(e).get(e) : NaN } count(e = "milliseconds", t) { if (!this.isValid) return NaN; const r = this.start.startOf(e, t); let s; return s = t?.useLocaleWeeks ? this.end.reconfigure({ locale: r.locale }) : this.end, s = s.startOf(e, t), Math.floor(s.diff(r, e).get(e)) + (s.valueOf() !== this.end.valueOf()) } hasSame(e) { return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, e)) } isEmpty() { return this.s.valueOf() === this.e.valueOf() } isAfter(e) { return !!this.isValid && this.s > e } isBefore(e) { return !!this.isValid && this.e <= e } contains(e) { return !!this.isValid && (this.s <= e && this.e > e) } set({ start: e, end: t } = {}) { return this.isValid ? Rr.fromDateTimes(e || this.s, t || this.e) : this } splitAt(...e) { if (!this.isValid) return []; const t = e.map(Ps).filter(e => this.contains(e)).sort((e, t) => e.toMillis() - t.toMillis()), r = []; let { s } = this, n = 0; for (; s < this.e;) { const e = t[n] || this.e, a = +e > +this.e ? this.e : e; r.push(Rr.fromDateTimes(s, a)), s = a, n += 1 } return r } splitBy(e) { const t = Cr.fromDurationLike(e); if (!this.isValid || !t.isValid || 0 === t.as("milliseconds")) return []; let r, { s } = this, n = 1; const a = []; for (; s < this.e;) { const e = this.start.plus(t.mapUnits(e => e * n)); r = +e > +this.e ? this.e : e, a.push(Rr.fromDateTimes(s, r)), s = r, n += 1 } return a } divideEqually(e) { return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [] } overlaps(e) { return this.e > e.s && this.s < e.e } abutsStart(e) { return !!this.isValid && +this.e === +e.s } abutsEnd(e) { return !!this.isValid && +e.e === +this.s } engulfs(e) { return !!this.isValid && (this.s <= e.s && this.e >= e.e) } equals(e) { return !(!this.isValid || !e.isValid) && (this.s.equals(e.s) && this.e.equals(e.e)) } intersection(e) { if (!this.isValid) return this; const t = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e; return t >= r ? null : Rr.fromDateTimes(t, r) } union(e) { if (!this.isValid) return this; const t = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e; return Rr.fromDateTimes(t, r) } static merge(e) { const [t, r] = e.sort((e, t) => e.s - t.s).reduce(([e, t], r) => t ? t.overlaps(r) || t.abutsStart(r) ? [e, t.union(r)] : [e.concat([t]), r] : [e, r], [[], null]); return r && t.push(r), t } static xor(e) { let t = null, r = 0; const s = [], n = e.map(e => [{ time: e.s, type: "s" }, { time: e.e, type: "e" }]), a = Array.prototype.concat(...n).sort((e, t) => e.time - t.time); for (const e of a) r += "s" === e.type ? 1 : -1, 1 === r ? t = e.time : (t && +t !== +e.time && s.push(Rr.fromDateTimes(t, e.time)), t = null); return Rr.merge(s) } difference(...e) { return Rr.xor([this].concat(e)).map(e => this.intersection(e)).filter(e => e && !e.isEmpty()) } toString() { return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Dr } [Symbol.for("nodejs.util.inspect.custom")]() { return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }` } toLocaleString(e = k, t = {}) { return this.isValid ? Ct.create(this.s.loc.clone(t), e).formatInterval(this) : Dr } toISO(e) { return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Dr } toISODate() { return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Dr } toISOTime(e) { return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Dr } toFormat(e, { separator: t = "  " } = {}) { return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : Dr } toDuration(e, t) { return this.isValid ? this.e.diff(this.s, e, t) : Cr.invalid(this.invalidReason) } mapEndpoints(e) { return Rr.fromDateTimes(e(this.s), e(this.e)) } } class Vr { static hasDST(e = Te.defaultZone) { const t = Es.now().setZone(e).set({ month: 12 }); return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset } static isValidIANAZone(e) { return B.isValidZone(e) } static normalizeZone(e) { return ye(e, Te.defaultZone) } static getStartOfWeek({ locale: e = null, locObj: t = null } = {}) { return (t || he.create(e)).getStartOfWeek() } static getMinimumDaysInFirstWeek({ locale: e = null, locObj: t = null } = {}) { return (t || he.create(e)).getMinDaysInFirstWeek() } static getWeekendWeekdays({ locale: e = null, locObj: t = null } = {}) { return (t || he.create(e)).getWeekendDays().slice() } static months(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: n = "gregory" } = {}) { return (s || he.create(t, r, n)).months(e) } static monthsFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: n = "gregory" } = {}) { return (s || he.create(t, r, n)).months(e, !0) } static weekdays(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) { return (s || he.create(t, r, null)).weekdays(e) } static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) { return (s || he.create(t, r, null)).weekdays(e, !0) } static meridiems({ locale: e = null } = {}) { return he.create(e).meridiems() } static eras(e = "short", { locale: t = null } = {}) { return he.create(t, null, "gregory").eras(e) } static features() { return { relative: Ge(), localeWeek: Ye() } } } function Ar(e, t) { const r = e => e.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), s = r(t) - r(e); return Math.floor(Cr.fromMillis(s).as("days")) } function zr(e, t, r, s) { let [n, a, o, i] = function (e, t, r) { const s = [["years", (e, t) => t.year - e.year], ["quarters", (e, t) => t.quarter - e.quarter + 4 * (t.year - e.year)], ["months", (e, t) => t.month - e.month + 12 * (t.year - e.year)], ["weeks", (e, t) => { const r = Ar(e, t); return (r - r % 7) / 7 }], ["days", Ar]], n = {}, a = e; let o, i; for (const [c, u] of s) r.indexOf(c) >= 0 && (o = c, n[c] = u(e, t), i = a.plus(n), i > t ? (n[c]--, (e = a.plus(n)) > t && (i = e, n[c]--, e = a.plus(n))) : e = i); return [e, n, i, o] }(e, t, r); const c = t - n, u = r.filter(e => ["hours", "minutes", "seconds", "milliseconds"].indexOf(e) >= 0); 0 === u.length && (o < t && (o = n.plus({ [i]: 1 })), o !== n && (a[i] = (a[i] || 0) + c / (o - n))); const l = Cr.fromObject(a, s); return u.length > 0 ? Cr.fromMillis(c, s).shiftTo(...u).plus(l) : l } function Fr(e, t = e => e) { return { regex: e, deser: ([e]) => t(function (e) { let t = parseInt(e, 10); if (isNaN(t)) { t = ""; for (let r = 0; r < e.length; r++) { const s = e.charCodeAt(r); if (-1 !== e[r].search(ge.hanidec)) t += $e.indexOf(e[r]); else for (const e in ve) { const [r, n] = ve[e]; s >= r && s <= n && (t += s - r) } } return parseInt(t, 10) } return t }(e)) } } const qr = `[ ${String.fromCharCode(160)}]`, Lr = new RegExp(qr, "g"); function Ur(e) { return e.replace(/\./g, "\\.?").replace(Lr, qr) } function Wr(e) { return e.replace(/\./g, "").replace(Lr, " ").toLowerCase() } function Zr(e, t) { return null === e ? null : { regex: RegExp(e.map(Ur).join("|")), deser: ([r]) => e.findIndex(e => Wr(r) === Wr(e)) + t } } function Jr(e, t) { return { regex: e, deser: ([, e, t]) => ft(e, t), groups: t } } function Hr(e) { return { regex: e, deser: ([e]) => e } } const Kr = { year: { "2-digit": "yy", numeric: "yyyyy" }, month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" }, day: { numeric: "d", "2-digit": "dd" }, weekday: { short: "EEE", long: "EEEE" }, dayperiod: "a", dayPeriod: "a", hour12: { numeric: "h", "2-digit": "hh" }, hour24: { numeric: "H", "2-digit": "HH" }, minute: { numeric: "m", "2-digit": "mm" }, second: { numeric: "s", "2-digit": "ss" }, timeZoneName: { long: "ZZZZZ", short: "ZZZ" } }; let Gr = null; function Yr(e, t) { return Array.prototype.concat(...e.map(e => function (e, t) { if (e.literal) return e; const r = Xr(Ct.macroTokenToFormatOpts(e.val), t); return null == r || r.includes(void 0) ? e : r }(e, t))) } class Br { constructor(e, t) { if (this.locale = e, this.format = t, this.tokens = Yr(Ct.parseFormat(t), e), this.units = this.tokens.map(t => function (e, t) { const r = be(t), s = be(t, "{2}"), n = be(t, "{3}"), a = be(t, "{4}"), o = be(t, "{6}"), i = be(t, "{1,2}"), c = be(t, "{1,3}"), u = be(t, "{1,6}"), l = be(t, "{1,9}"), d = be(t, "{2,4}"), h = be(t, "{4,6}"), m = e => { return { regex: RegExp((t = e.val, t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"))), deser: ([e]) => e, literal: !0 }; var t }, f = (f => { if (e.literal) return m(f); switch (f.val) { case "G": return Zr(t.eras("short"), 0); case "GG": return Zr(t.eras("long"), 0); case "y": return Fr(u); case "yy": case "kk": return Fr(d, ht); case "yyyy": case "kkkk": return Fr(a); case "yyyyy": return Fr(h); case "yyyyyy": return Fr(o); case "M": case "L": case "d": case "H": case "h": case "m": case "q": case "s": case "W": return Fr(i); case "MM": case "LL": case "dd": case "HH": case "hh": case "mm": case "qq": case "ss": case "WW": return Fr(s); case "MMM": return Zr(t.months("short", !0), 1); case "MMMM": return Zr(t.months("long", !0), 1); case "LLL": return Zr(t.months("short", !1), 1); case "LLLL": return Zr(t.months("long", !1), 1); case "o": case "S": return Fr(c); case "ooo": case "SSS": return Fr(n); case "u": return Hr(l); case "uu": return Hr(i); case "uuu": case "E": case "c": return Fr(r); case "a": return Zr(t.meridiems(), 0); case "EEE": return Zr(t.weekdays("short", !1), 1); case "EEEE": return Zr(t.weekdays("long", !1), 1); case "ccc": return Zr(t.weekdays("short", !0), 1); case "cccc": return Zr(t.weekdays("long", !0), 1); case "Z": case "ZZ": return Jr(new RegExp(`([+-]${i.source})(?::(${s.source}))?`), 2); case "ZZZ": return Jr(new RegExp(`([+-]${i.source})(${s.source})?`), 2); case "z": return Hr(/[a-z_+-/]{1,256}?/i); case " ": return Hr(/[^\S\n\r]/); default: return m(f) } })(e) || { invalidReason: "missing Intl.DateTimeFormat.formatToParts support" }; return f.token = e, f }(t, e)), this.disqualifyingUnit = this.units.find(e => e.invalidReason), !this.disqualifyingUnit) { const [e, t] = [`^${(r = this.units).map(e => e.regex).reduce((e, t) => `${e}(${t.source})`, "")}$`, r]; this.regex = RegExp(e, "i"), this.handlers = t } var r } explainFromTokens(e) { if (this.isValid) { const [t, r] = function (e, t, r) { const s = e.match(t); if (s) { const e = {}; let t = 1; for (const n in r) if (Qe(r, n)) { const a = r[n], o = a.groups ? a.groups + 1 : 1; !a.literal && a.token && (e[a.token.val[0]] = a.deser(s.slice(t, t + o))), t += o } return [s, e] } return [s, {}] }(e, this.regex, this.handlers), [s, n, a] = r ? function (e) { let t, r = null; return Je(e.z) || (r = B.create(e.z)), Je(e.Z) || (r || (r = new fe(e.Z)), t = e.Z), Je(e.q) || (e.M = 3 * (e.q - 1) + 1), Je(e.h) || (e.h < 12 && 1 === e.a ? e.h += 12 : 12 === e.h && 0 === e.a && (e.h = 0)), 0 === e.G && e.y && (e.y = -e.y), Je(e.u) || (e.S = nt(e.u)), [Object.keys(e).reduce((t, r) => { const s = (e => { switch (e) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": case "H": return "hour"; case "d": return "day"; case "o": return "ordinal"; case "L": case "M": return "month"; case "y": return "year"; case "E": case "c": return "weekday"; case "W": return "weekNumber"; case "k": return "weekYear"; case "q": return "quarter"; default: return null } })(r); return s && (t[s] = e[r]), t }, {}), r, t] }(r) : [null, null, void 0]; if (Qe(r, "a") && Qe(r, "H")) throw new y("Can't include meridiem when specifying 24-hour format"); return { input: e, tokens: this.tokens, regex: this.regex, rawMatches: t, matches: r, result: s, zone: n, specificOffset: a } } return { input: e, tokens: this.tokens, invalidReason: this.invalidReason } } get isValid() { return !this.disqualifyingUnit } get invalidReason() { return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null } } function Qr(e, t, r) { return new Br(e, r).explainFromTokens(t) } function Xr(e, t) { if (!e) return null; const r = Ct.create(t, e).dtFormatter((Gr || (Gr = Es.fromMillis(1555555555555)), Gr)), s = r.formatToParts(), n = r.resolvedOptions(); return s.map(t => function (e, t, r) { const { type: s, value: n } = e; if ("literal" === s) { const e = /^\s+$/.test(n); return { literal: !e, val: e ? " " : n } } const a = t[s]; let o = s; "hour" === s && (o = null != t.hour12 ? t.hour12 ? "hour12" : "hour24" : null != t.hourCycle ? "h11" === t.hourCycle || "h12" === t.hourCycle ? "hour12" : "hour24" : r.hour12 ? "hour12" : "hour24"); let i = Kr[o]; if ("object" == typeof i && (i = i[a]), i) return { literal: !1, val: i } }(t, e, n)) } const es = "Invalid DateTime", ts = 864e13; function rs(e) { return new xe("unsupported zone", `the zone "${e.name}" is not supported`) } function ss(e) { return null === e.weekData && (e.weekData = ze(e.c)), e.weekData } function ns(e) { return null === e.localWeekData && (e.localWeekData = ze(e.c, e.loc.getMinDaysInFirstWeek(), e.loc.getStartOfWeek())), e.localWeekData } function as(e, t) { const r = { ts: e.ts, zone: e.zone, c: e.c, o: e.o, loc: e.loc, invalid: e.invalid }; return new Es({ ...r, ...t, old: r }) } function os(e, t, r) { let s = e - 60 * t * 1e3; const n = r.offset(s); if (t === n) return [s, t]; s -= 60 * (n - t) * 1e3; const a = r.offset(s); return n === a ? [s, n] : [e - 60 * Math.min(n, a) * 1e3, Math.max(n, a)] } function is(e, t) { const r = new Date(e += 60 * t * 1e3); return { year: r.getUTCFullYear(), month: r.getUTCMonth() + 1, day: r.getUTCDate(), hour: r.getUTCHours(), minute: r.getUTCMinutes(), second: r.getUTCSeconds(), millisecond: r.getUTCMilliseconds() } } function cs(e, t, r) { return os(ut(e), t, r) } function us(e, t) { const r = e.o, s = e.c.year + Math.trunc(t.years), n = e.c.month + Math.trunc(t.months) + 3 * Math.trunc(t.quarters), a = { ...e.c, year: s, month: n, day: Math.min(e.c.day, ct(s, n)) + Math.trunc(t.days) + 7 * Math.trunc(t.weeks) }, o = Cr.fromObject({ years: t.years - Math.trunc(t.years), quarters: t.quarters - Math.trunc(t.quarters), months: t.months - Math.trunc(t.months), weeks: t.weeks - Math.trunc(t.weeks), days: t.days - Math.trunc(t.days), hours: t.hours, minutes: t.minutes, seconds: t.seconds, milliseconds: t.milliseconds }).as("milliseconds"), i = ut(a); let [c, u] = os(i, r, e.zone); return 0 !== o && (c += o, u = e.zone.offset(c)), { ts: c, o: u } } function ls(e, t, r, s, n, a) { const { setZone: o, zone: i } = r; if (e && 0 !== Object.keys(e).length || t) { const s = t || i, n = Es.fromObject(e, { ...r, zone: s, specificOffset: a }); return o ? n : n.setZone(i) } return Es.invalid(new xe("unparsable", `the input "${n}" can't be parsed as ${s}`)) } function ds(e, t, r = !0) { return e.isValid ? Ct.create(he.create("en-US"), { allowZ: r, forceSimple: !0 }).formatDateTimeFromString(e, t) : null } function hs(e, t, r) { const s = e.c.year > 9999 || e.c.year < 0; let n = ""; if (s && e.c.year >= 0 && (n += "+"), n += tt(e.c.year, s ? 6 : 4), "year" === r) return n; if (t) { if (n += "-", n += tt(e.c.month), "month" === r) return n; n += "-" } else if (n += tt(e.c.month), "month" === r) return n; return n += tt(e.c.day), n } function ms(e, t, r, s, n, a, o) { let i = !r || 0 !== e.c.millisecond || 0 !== e.c.second, c = ""; switch (o) { case "day": case "month": case "year": break; default: if (c += tt(e.c.hour), "hour" === o) break; if (t) { if (c += ":", c += tt(e.c.minute), "minute" === o) break; i && (c += ":", c += tt(e.c.second)) } else { if (c += tt(e.c.minute), "minute" === o) break; i && (c += tt(e.c.second)) } if ("second" === o) break; !i || s && 0 === e.c.millisecond || (c += ".", c += tt(e.c.millisecond, 3)) }return n && (e.isOffsetFixed && 0 === e.offset && !a ? c += "Z" : e.o < 0 ? (c += "-", c += tt(Math.trunc(-e.o / 60)), c += ":", c += tt(Math.trunc(-e.o % 60))) : (c += "+", c += tt(Math.trunc(e.o / 60)), c += ":", c += tt(Math.trunc(e.o % 60)))), a && (c += "[" + e.zone.ianaName + "]"), c } const fs = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, ps = { weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, ys = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, gs = ["year", "month", "day", "hour", "minute", "second", "millisecond"], vs = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], $s = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; function ws(e) { const t = { year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter", second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal" }[e.toLowerCase()]; if (!t) throw new g(e); return t } function bs(e) { switch (e.toLowerCase()) { case "localweekday": case "localweekdays": return "localWeekday"; case "localweeknumber": case "localweeknumbers": return "localWeekNumber"; case "localweekyear": case "localweekyears": return "localWeekYear"; default: return ws(e) } } function _s(e, t) { const r = ye(t.zone, Te.defaultZone); if (!r.isValid) return Es.invalid(rs(r)); const s = he.fromObject(t); let n, a; if (Je(e.year)) n = Te.now(); else { for (const t of gs) Je(e[t]) && (e[t] = fs[t]); const t = We(e) || Ze(e); if (t) return Es.invalid(t); const s = function (e) { if (void 0 === Ns && (Ns = Te.now()), "iana" !== e.type) return e.offset(Ns); const t = e.name; let r = Os.get(t); return void 0 === r && (r = e.offset(Ns), Os.set(t, r)), r }(r);[n, a] = cs(e, s, r) } return new Es({ ts: n, zone: r, loc: s, o: a }) } function ks(e, t, r) { const s = !!Je(r.round) || r.round, n = Je(r.rounding) ? "trunc" : r.rounding, a = (e, a) => { e = at(e, s || r.calendary ? 0 : 2, r.calendary ? "round" : n); return t.loc.clone(r).relFormatter(r).format(e, a) }, o = s => r.calendary ? t.hasSame(e, s) ? 0 : t.startOf(s).diff(e.startOf(s), s).get(s) : t.diff(e, s).get(s); if (r.unit) return a(o(r.unit), r.unit); for (const e of r.units) { const t = o(e); if (Math.abs(t) >= 1) return a(t, e) } return a(e > t ? -0 : 0, r.units[r.units.length - 1]) } function Ss(e) { let t, r = {}; return e.length > 0 && "object" == typeof e[e.length - 1] ? (r = e[e.length - 1], t = Array.from(e).slice(0, e.length - 1)) : t = Array.from(e), [r, t] } let Ns; const Os = new Map; class Es { constructor(e) { const t = e.zone || Te.defaultZone; let r = e.invalid || (Number.isNaN(e.ts) ? new xe("invalid input") : null) || (t.isValid ? null : rs(t)); this.ts = Je(e.ts) ? Te.now() : e.ts; let s = null, n = null; if (!r) { if (e.old && e.old.ts === this.ts && e.old.zone.equals(t)) [s, n] = [e.old.c, e.old.o]; else { const a = He(e.o) && !e.old ? e.o : t.offset(this.ts); s = is(this.ts, a), r = Number.isNaN(s.year) ? new xe("invalid input") : null, s = r ? null : s, n = r ? null : a } } this._zone = t, this.loc = e.loc || he.create(), this.invalid = r, this.weekData = null, this.localWeekData = null, this.c = s, this.o = n, this.isLuxonDateTime = !0 } static now() { return new Es({}) } static local() { const [e, t] = Ss(arguments), [r, s, n, a, o, i, c] = t; return _s({ year: r, month: s, day: n, hour: a, minute: o, second: i, millisecond: c }, e) } static utc() { const [e, t] = Ss(arguments), [r, s, n, a, o, i, c] = t; return e.zone = fe.utcInstance, _s({ year: r, month: s, day: n, hour: a, minute: o, second: i, millisecond: c }, e) } static fromJSDate(e, t = {}) { const r = (s = e, "[object Date]" === Object.prototype.toString.call(s) ? e.valueOf() : NaN); var s; if (Number.isNaN(r)) return Es.invalid("invalid input"); const n = ye(t.zone, Te.defaultZone); return n.isValid ? new Es({ ts: r, zone: n, loc: he.fromObject(t) }) : Es.invalid(rs(n)) } static fromMillis(e, t = {}) { if (He(e)) return e < -ts || e > ts ? Es.invalid("Timestamp out of range") : new Es({ ts: e, zone: ye(t.zone, Te.defaultZone), loc: he.fromObject(t) }); throw new v(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`) } static fromSeconds(e, t = {}) { if (He(e)) return new Es({ ts: 1e3 * e, zone: ye(t.zone, Te.defaultZone), loc: he.fromObject(t) }); throw new v("fromSeconds requires a numerical input") } static fromObject(e, t = {}) { e = e || {}; const r = ye(t.zone, Te.defaultZone); if (!r.isValid) return Es.invalid(rs(r)); const s = he.fromObject(t), n = yt(e, bs), { minDaysInFirstWeek: a, startOfWeek: o } = Ue(n, s), i = Te.now(), c = Je(t.specificOffset) ? r.offset(i) : t.specificOffset, u = !Je(n.ordinal), l = !Je(n.year), d = !Je(n.month) || !Je(n.day), h = l || d, m = n.weekYear || n.weekNumber; if ((h || u) && m) throw new y("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (d && u) throw new y("Can't mix ordinal dates with month/day"); const f = m || n.weekday && !h; let p, g, v = is(i, c); f ? (p = vs, g = ps, v = ze(v, a, o)) : u ? (p = $s, g = ys, v = qe(v)) : (p = gs, g = fs); let $ = !1; for (const e of p) { Je(n[e]) ? n[e] = $ ? g[e] : v[e] : $ = !0 } const w = f ? function (e, t = 4, r = 1) { const s = Ke(e.weekYear), n = et(e.weekNumber, 1, dt(e.weekYear, t, r)), a = et(e.weekday, 1, 7); return s ? n ? !a && Ce("weekday", e.weekday) : Ce("week", e.weekNumber) : Ce("weekYear", e.weekYear) }(n, a, o) : u ? function (e) { const t = Ke(e.year), r = et(e.ordinal, 1, it(e.year)); return t ? !r && Ce("ordinal", e.ordinal) : Ce("year", e.year) }(n) : We(n), b = w || Ze(n); if (b) return Es.invalid(b); const _ = f ? Fe(n, a, o) : u ? Le(n) : n, [k, S] = cs(_, c, r), N = new Es({ ts: k, zone: r, o: S, loc: s }); return n.weekday && h && e.weekday !== N.weekday ? Es.invalid("mismatched weekday", `you can't specify both a weekday of ${n.weekday} and a date of ${N.toISO()}`) : N.isValid ? N : Es.invalid(N.invalid) } static fromISO(e, t = {}) { const [r, s] = function (e) { return At(e, [lr, fr], [dr, pr], [hr, yr], [mr, gr]) }(e); return ls(r, s, t, "ISO 8601", e) } static fromRFC2822(e, t = {}) { const [r, s] = function (e) { return At(function (e) { return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim() }(e), [sr, nr]) }(e); return ls(r, s, t, "RFC 2822", e) } static fromHTTP(e, t = {}) { const [r, s] = function (e) { return At(e, [ar, cr], [or, cr], [ir, ur]) }(e); return ls(r, s, t, "HTTP", t) } static fromFormat(e, t, r = {}) { if (Je(e) || Je(t)) throw new v("fromFormat requires an input string and a format"); const { locale: s = null, numberingSystem: n = null } = r, a = he.fromOpts({ locale: s, numberingSystem: n, defaultToEN: !0 }), [o, i, c, u] = function (e, t, r) { const { result: s, zone: n, specificOffset: a, invalidReason: o } = Qr(e, t, r); return [s, n, a, o] }(a, e, t); return u ? Es.invalid(u) : ls(o, i, r, `format ${t}`, e, c) } static fromString(e, t, r = {}) { return Es.fromFormat(e, t, r) } static fromSQL(e, t = {}) { const [r, s] = function (e) { return At(e, [$r, fr], [wr, br]) }(e); return ls(r, s, t, "SQL", e) } static invalid(e, t = null) { if (!e) throw new v("need to specify a reason the DateTime is invalid"); const r = e instanceof xe ? e : new xe(e, t); if (Te.throwOnInvalid) throw new m(r); return new Es({ invalid: r }) } static isDateTime(e) { return e && e.isLuxonDateTime || !1 } static parseFormatForOpts(e, t = {}) { const r = Xr(e, he.fromObject(t)); return r ? r.map(e => e ? e.val : null).join("") : null } static expandFormat(e, t = {}) { return Yr(Ct.parseFormat(e), he.fromObject(t)).map(e => e.val).join("") } static resetCache() { Ns = void 0, Os.clear() } get(e) { return this[e] } get isValid() { return null === this.invalid } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } get outputCalendar() { return this.isValid ? this.loc.outputCalendar : null } get zone() { return this._zone } get zoneName() { return this.isValid ? this.zone.name : null } get year() { return this.isValid ? this.c.year : NaN } get quarter() { return this.isValid ? Math.ceil(this.c.month / 3) : NaN } get month() { return this.isValid ? this.c.month : NaN } get day() { return this.isValid ? this.c.day : NaN } get hour() { return this.isValid ? this.c.hour : NaN } get minute() { return this.isValid ? this.c.minute : NaN } get second() { return this.isValid ? this.c.second : NaN } get millisecond() { return this.isValid ? this.c.millisecond : NaN } get weekYear() { return this.isValid ? ss(this).weekYear : NaN } get weekNumber() { return this.isValid ? ss(this).weekNumber : NaN } get weekday() { return this.isValid ? ss(this).weekday : NaN } get isWeekend() { return this.isValid && this.loc.getWeekendDays().includes(this.weekday) } get localWeekday() { return this.isValid ? ns(this).weekday : NaN } get localWeekNumber() { return this.isValid ? ns(this).weekNumber : NaN } get localWeekYear() { return this.isValid ? ns(this).weekYear : NaN } get ordinal() { return this.isValid ? qe(this.c).ordinal : NaN } get monthShort() { return this.isValid ? Vr.months("short", { locObj: this.loc })[this.month - 1] : null } get monthLong() { return this.isValid ? Vr.months("long", { locObj: this.loc })[this.month - 1] : null } get weekdayShort() { return this.isValid ? Vr.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null } get weekdayLong() { return this.isValid ? Vr.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null } get offset() { return this.isValid ? +this.o : NaN } get offsetNameShort() { return this.isValid ? this.zone.offsetName(this.ts, { format: "short", locale: this.locale }) : null } get offsetNameLong() { return this.isValid ? this.zone.offsetName(this.ts, { format: "long", locale: this.locale }) : null } get isOffsetFixed() { return this.isValid ? this.zone.isUniversal : null } get isInDST() { return !this.isOffsetFixed && (this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset) } getPossibleOffsets() { if (!this.isValid || this.isOffsetFixed) return [this]; const e = 864e5, t = 6e4, r = ut(this.c), s = this.zone.offset(r - e), n = this.zone.offset(r + e), a = this.zone.offset(r - s * t), o = this.zone.offset(r - n * t); if (a === o) return [this]; const i = r - a * t, c = r - o * t, u = is(i, a), l = is(c, o); return u.hour === l.hour && u.minute === l.minute && u.second === l.second && u.millisecond === l.millisecond ? [as(this, { ts: i }), as(this, { ts: c })] : [this] } get isInLeapYear() { return ot(this.year) } get daysInMonth() { return ct(this.year, this.month) } get daysInYear() { return this.isValid ? it(this.year) : NaN } get weeksInWeekYear() { return this.isValid ? dt(this.weekYear) : NaN } get weeksInLocalWeekYear() { return this.isValid ? dt(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN } resolvedLocaleOptions(e = {}) { const { locale: t, numberingSystem: r, calendar: s } = Ct.create(this.loc.clone(e), e).resolvedOptions(this); return { locale: t, numberingSystem: r, outputCalendar: s } } toUTC(e = 0, t = {}) { return this.setZone(fe.instance(e), t) } toLocal() { return this.setZone(Te.defaultZone) } setZone(e, { keepLocalTime: t = !1, keepCalendarTime: r = !1 } = {}) { if ((e = ye(e, Te.defaultZone)).equals(this.zone)) return this; if (e.isValid) { let s = this.ts; if (t || r) { const t = e.offset(this.ts), r = this.toObject();[s] = cs(r, t, e) } return as(this, { ts: s, zone: e }) } return Es.invalid(rs(e)) } reconfigure({ locale: e, numberingSystem: t, outputCalendar: r } = {}) { return as(this, { loc: this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: r }) }) } setLocale(e) { return this.reconfigure({ locale: e }) } set(e) { if (!this.isValid) return this; const t = yt(e, bs), { minDaysInFirstWeek: r, startOfWeek: s } = Ue(t, this.loc), n = !Je(t.weekYear) || !Je(t.weekNumber) || !Je(t.weekday), a = !Je(t.ordinal), o = !Je(t.year), i = !Je(t.month) || !Je(t.day), c = o || i, u = t.weekYear || t.weekNumber; if ((c || a) && u) throw new y("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (i && a) throw new y("Can't mix ordinal dates with month/day"); let l; n ? l = Fe({ ...ze(this.c, r, s), ...t }, r, s) : Je(t.ordinal) ? (l = { ...this.toObject(), ...t }, Je(t.day) && (l.day = Math.min(ct(l.year, l.month), l.day))) : l = Le({ ...qe(this.c), ...t }); const [d, h] = cs(l, this.o, this.zone); return as(this, { ts: d, o: h }) } plus(e) { if (!this.isValid) return this; return as(this, us(this, Cr.fromDurationLike(e))) } minus(e) { if (!this.isValid) return this; return as(this, us(this, Cr.fromDurationLike(e).negate())) } startOf(e, { useLocaleWeeks: t = !1 } = {}) { if (!this.isValid) return this; const r = {}, s = Cr.normalizeUnit(e); switch (s) { case "years": r.month = 1; case "quarters": case "months": r.day = 1; case "weeks": case "days": r.hour = 0; case "hours": r.minute = 0; case "minutes": r.second = 0; case "seconds": r.millisecond = 0 }if ("weeks" === s) if (t) { const e = this.loc.getStartOfWeek(), { weekday: t } = this; t < e && (r.weekNumber = this.weekNumber - 1), r.weekday = e } else r.weekday = 1; if ("quarters" === s) { const e = Math.ceil(this.month / 3); r.month = 3 * (e - 1) + 1 } return this.set(r) } endOf(e, t) { return this.isValid ? this.plus({ [e]: 1 }).startOf(e, t).minus(1) : this } toFormat(e, t = {}) { return this.isValid ? Ct.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : es } toLocaleString(e = k, t = {}) { return this.isValid ? Ct.create(this.loc.clone(t), e).formatDateTime(this) : es } toLocaleParts(e = {}) { return this.isValid ? Ct.create(this.loc.clone(e), e).formatDateTimeParts(this) : [] } toISO({ format: e = "extended", suppressSeconds: t = !1, suppressMilliseconds: r = !1, includeOffset: s = !0, extendedZone: n = !1, precision: a = "milliseconds" } = {}) { if (!this.isValid) return null; const o = "extended" === e; let i = hs(this, o, a = ws(a)); return gs.indexOf(a) >= 3 && (i += "T"), i += ms(this, o, t, r, s, n, a), i } toISODate({ format: e = "extended", precision: t = "day" } = {}) { return this.isValid ? hs(this, "extended" === e, ws(t)) : null } toISOWeekDate() { return ds(this, "kkkk-'W'WW-c") } toISOTime({ suppressMilliseconds: e = !1, suppressSeconds: t = !1, includeOffset: r = !0, includePrefix: s = !1, extendedZone: n = !1, format: a = "extended", precision: o = "milliseconds" } = {}) { if (!this.isValid) return null; return o = ws(o), (s && gs.indexOf(o) >= 3 ? "T" : "") + ms(this, "extended" === a, t, e, r, n, o) } toRFC2822() { return ds(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1) } toHTTP() { return ds(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'") } toSQLDate() { return this.isValid ? hs(this, !0) : null } toSQLTime({ includeOffset: e = !0, includeZone: t = !1, includeOffsetSpace: r = !0 } = {}) { let s = "HH:mm:ss.SSS"; return (t || e) && (r && (s += " "), t ? s += "z" : e && (s += "ZZ")), ds(this, s, !0) } toSQL(e = {}) { return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null } toString() { return this.isValid ? this.toISO() : es } [Symbol.for("nodejs.util.inspect.custom")]() { return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }` } valueOf() { return this.toMillis() } toMillis() { return this.isValid ? this.ts : NaN } toSeconds() { return this.isValid ? this.ts / 1e3 : NaN } toUnixInteger() { return this.isValid ? Math.floor(this.ts / 1e3) : NaN } toJSON() { return this.toISO() } toBSON() { return this.toJSDate() } toObject(e = {}) { if (!this.isValid) return {}; const t = { ...this.c }; return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t } toJSDate() { return new Date(this.isValid ? this.ts : NaN) } diff(e, t = "milliseconds", r = {}) { if (!this.isValid || !e.isValid) return Cr.invalid("created by diffing an invalid DateTime"); const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, n = (i = t, Array.isArray(i) ? i : [i]).map(Cr.normalizeUnit), a = e.valueOf() > this.valueOf(), o = zr(a ? this : e, a ? e : this, n, s); var i; return a ? o.negate() : o } diffNow(e = "milliseconds", t = {}) { return this.diff(Es.now(), e, t) } until(e) { return this.isValid ? Rr.fromDateTimes(this, e) : this } hasSame(e, t, r) { if (!this.isValid) return !1; const s = e.valueOf(), n = this.setZone(e.zone, { keepLocalTime: !0 }); return n.startOf(t, r) <= s && s <= n.endOf(t, r) } equals(e) { return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc) } toRelative(e = {}) { if (!this.isValid) return null; const t = e.base || Es.fromObject({}, { zone: this.zone }), r = e.padding ? this < t ? -e.padding : e.padding : 0; let s = ["years", "months", "days", "hours", "minutes", "seconds"], n = e.unit; return Array.isArray(e.unit) && (s = e.unit, n = void 0), ks(t, this.plus(r), { ...e, numeric: "always", units: s, unit: n }) } toRelativeCalendar(e = {}) { return this.isValid ? ks(e.base || Es.fromObject({}, { zone: this.zone }), this, { ...e, numeric: "auto", units: ["years", "months", "days"], calendary: !0 }) : null } static min(...e) { if (!e.every(Es.isDateTime)) throw new v("min requires all arguments be DateTimes"); return Be(e, e => e.valueOf(), Math.min) } static max(...e) { if (!e.every(Es.isDateTime)) throw new v("max requires all arguments be DateTimes"); return Be(e, e => e.valueOf(), Math.max) } static fromFormatExplain(e, t, r = {}) { const { locale: s = null, numberingSystem: n = null } = r; return Qr(he.fromOpts({ locale: s, numberingSystem: n, defaultToEN: !0 }), e, t) } static fromStringExplain(e, t, r = {}) { return Es.fromFormatExplain(e, t, r) } static buildFormatParser(e, t = {}) { const { locale: r = null, numberingSystem: s = null } = t, n = he.fromOpts({ locale: r, numberingSystem: s, defaultToEN: !0 }); return new Br(n, e) } static fromFormatParser(e, t, r = {}) { if (Je(e) || Je(t)) throw new v("fromFormatParser requires an input string and a format parser"); const { locale: s = null, numberingSystem: n = null } = r, a = he.fromOpts({ locale: s, numberingSystem: n, defaultToEN: !0 }); if (!a.equals(t.locale)) throw new v(`fromFormatParser called with a locale of ${a}, but the format parser was created for ${t.locale}`); const { result: o, zone: i, specificOffset: c, invalidReason: u } = t.explainFromTokens(e); return u ? Es.invalid(u) : ls(o, i, r, `format ${t.format}`, e, c) } static get DATE_SHORT() { return k } static get DATE_MED() { return S } static get DATE_MED_WITH_WEEKDAY() { return N } static get DATE_FULL() { return O } static get DATE_HUGE() { return E } static get TIME_SIMPLE() { return P } static get TIME_WITH_SECONDS() { return j } static get TIME_WITH_SHORT_OFFSET() { return T } static get TIME_WITH_LONG_OFFSET() { return x } static get TIME_24_SIMPLE() { return I } static get TIME_24_WITH_SECONDS() { return M } static get TIME_24_WITH_SHORT_OFFSET() { return C } static get TIME_24_WITH_LONG_OFFSET() { return D } static get DATETIME_SHORT() { return R } static get DATETIME_SHORT_WITH_SECONDS() { return V } static get DATETIME_MED() { return A } static get DATETIME_MED_WITH_SECONDS() { return z } static get DATETIME_MED_WITH_WEEKDAY() { return F } static get DATETIME_FULL() { return q } static get DATETIME_FULL_WITH_SECONDS() { return L } static get DATETIME_HUGE() { return U } static get DATETIME_HUGE_WITH_SECONDS() { return W } } function Ps(e) { if (Es.isDateTime(e)) return e; if (e && e.valueOf && He(e.valueOf())) return Es.fromJSDate(e); if (e && "object" == typeof e) return Es.fromObject(e); throw new v(`Unknown datetime argument: ${e}, of type ${typeof e}`) } class js extends Error { constructor(e, t) { super(e), this.context = t } } class Ts extends js { } class xs extends Ts { constructor(e) { super(e || "This function is not implemented") } } class Is extends Ts { } class Ms extends Ts { } class Cs extends Error { } class Ds extends Ts { constructor(e, t, r) { super(`Value is not of type ${r}: ${null == t ? void 0 : t.toString()}`, e), this.value = t, this.expectedType = r } } class Rs extends Ds { constructor(e, t) { super(e, t, "ArrayLike") } } class Vs extends Ds { constructor(e, t) { super(e, t, "boolean") } } class As extends Ds { constructor(e, t) { super(e, t, "number") } } class zs extends Ds { constructor(e, t) { super(e, t, "Date") } } class Fs extends Ds { constructor(e, t) { super(e, t, "number | Date") } } class qs extends Ds { constructor(e, t) { super(e, t, "Duration") } } function Ls(e, t) { const r = Es.fromISO(e).toJSDate(); if (isNaN(r.getTime())) throw new Ts(`Date "${e}" could not be parsed`, t); return r } class Us extends i { constructor(e, t = !1, r) { super(), this.path = e, this.isDate = t, this.defaultValue = r } static getPropertyByString(e, t, r, s) { const n = (t = (t = t.replace(/\[(\w+)]/g, ".$1")).replace(/^\./, "")).split("."); for (let a = 0, o = n.length; a < o; ++a) { const o = n[a]; if ("object" != typeof e) { if (void 0 !== r) return r; throw new Is("Invalid path in data: " + t + " is of invalid type " + typeof e + " with value " + e, s) } if (!(o in e)) { if (void 0 !== r) return r; throw new Is("Undefinded path in data: " + t, s) } e = e[o] } return e } getPropertyByString(e) { return Us.getPropertyByString(e, this.path, this.defaultValue, this) } validate() { return !!this.path } toJsonReady() { const e = { type: "atom", path: this.path }; return this.isDate && (e.isDate = !0), void 0 !== this.defaultValue && (e.default = this.defaultValue), e } evaluate(e) { return n(this, void 0, void 0, function* () { let t = this.getPropertyByString(e); return "string" == typeof t && this.isDate ? Ls(t, this) : t }) } } var Ws, Zs, Js, Hs; function Ks(e) { return e instanceof i ? e.toJsonReady() : e instanceof Date ? Es.fromJSDate(e).toISO() : e } !function (e) { e.add = "add", e.subtract = "subtract", e.multiply = "multiply", e.divide = "divide", e.modulo = "modulo" }(Ws || (Ws = {})); class Gs extends i { constructor(e, t) { super(), this.arguments = e, this.operation = t } evaluate(e) { return n(this, void 0, void 0, function* () { let t; switch (this.operation) { case Ws.add: t = (e, t) => e + t; break; case Ws.subtract: t = (e, t) => e - t; break; case Ws.multiply: t = (e, t) => e * t; break; case Ws.divide: t = (e, t) => { if (0 === t) throw new Ts("Division by zero is not allowed", this); return e / t }; break; case Ws.modulo: t = (e, t) => { if (0 === t) throw new Ts("Division by zero is not allowed", this); return e - Math.floor(e / t) * t } }let r = yield Promise.all(this.arguments.map(t => n(this, void 0, void 0, function* () { return t instanceof i ? yield t.evaluate(e) : t }))); for (const e of r) if (e instanceof Date) throw new Ts("No dates in calculation allowed! Use dateCalculation", this); return r.splice(1).reduce((e, r) => Math.round(1e13 * t(e, r)) / 1e13, r[0]) }) } toJsonReady() { return { type: "calculation", operation: this.operation, arguments: this.arguments.map(Ks) } } validate() { return this.arguments.length >= 2 && this.arguments.map(e => e instanceof i ? e.validate() : !!e).reduce((e, t) => e && t) } } !function (e) { e.equal = "equal", e.smaller = "smaller", e.greater = "greater", e.smallerOrEqual = "smallerOrEqual", e.greaterOrEqual = "greaterOrEqual" }(Zs || (Zs = {})); class Ys extends i { constructor(e, t, r = !1, s = !1) { super(), this.arguments = e, this.operation = t, this.dates = r, this.allowDifferentTypes = s } toJsonReady() { const e = { type: "comparison", operation: this.operation, arguments: this.arguments.map(Ks) }; return this.dates && (e.dates = !0), e } evaluate(e) { return n(this, void 0, void 0, function* () { let t = this.arguments[0] instanceof i ? yield this.arguments[0].evaluate(e) : this.arguments[0], r = this.arguments[1] instanceof i ? yield this.arguments[1].evaluate(e) : this.arguments[1]; if (void 0 === t || void 0 === r) return !1; if (typeof t != typeof r && !this.allowDifferentTypes) throw new Ts("Elements in comparison must have the same type", this); switch (t instanceof Date && (t = t.getTime()), r instanceof Date && (r = r.getTime()), this.operation) { case Zs.equal: return t === r; case Zs.greater: return t > r; case Zs.greaterOrEqual: return t >= r; case Zs.smaller: return t < r; case Zs.smallerOrEqual: return t <= r; default: throw new xs("Unknown operation: " + this.operation) } }) } validate() { return 2 === this.arguments.length && this.arguments.map(e => e instanceof i ? e.validate() : !!e).reduce((e, t) => e && t) } } class Bs extends i { constructor(e, t, r, s = "index", n) { super(), this.quantifier = e, this.array = t, this.placeholder = r, this.formula = n, this.indexPlaceholder = s } evaluate(e) { return n(this, void 0, void 0, function* () { let t; if (t = Array.isArray(this.array) ? yield Promise.all(this.array.map(t => t.evaluate(e))) : yield this.array.evaluate(e), !Array.isArray(t)) throw new Ts(`Property 'array' in a quantifier must be an array! (Actual: ${t}, typeof ${typeof t})`, this); for (let r = 0; r < t.length; r++) { e[this.placeholder] = t[r], e[this.indexPlaceholder] = r; const s = yield this.formula.evaluate(e); if ("forall" === this.quantifier && !s) return !1; if ("exists" === this.quantifier && s) return !0 } return "forall" === this.quantifier }) } toJsonReady() { return { type: this.quantifier, array: Array.isArray(this.array) ? this.array.map(e => e.toJsonReady()) : this.array.toJsonReady(), placeholder: this.placeholder, rule: this.formula.toJsonReady() } } validate() { return 0 !== this.placeholder.length && (Array.isArray(this.array) ? this.array.map(e => e.validate()).reduce((e, t) => e && t) : this.array.validate()) } } class Qs extends i { constructor(e, t) { super(), this.macro = e, this.array = t } evaluate(e) { return n(this, void 0, void 0, function* () { var t; switch (this.macro) { case "now": return new Date; case "length": const r = yield null === (t = this.array) || void 0 === t ? void 0 : t.evaluate(e); return function (e, t) { if (!(null == e ? void 0 : e.hasOwnProperty("length"))) throw new Rs(t, e) }(r, this), r.length } }) } toJsonReady() { var e; return { type: "macro", macro: { type: this.macro, array: null === (e = this.array) || void 0 === e ? void 0 : e.toJsonReady() } } } validate() { return !("length" === this.macro && !this.array) } } class Xs extends i { constructor(e, t) { super(), this.options = e, this.formula = t } evaluate(e) { return n(this, void 0, void 0, function* () { if (!this.formula) throw new Ts("Empty formula", this); return this.formula.evaluate(yield this.enrichData(e)) }) } validate() { if (!this.formula) throw new Ts("Empty formula", this); return this.formula.validate() } toJsonReady() { return { type: "plugin", name: this.getName(), options: this.options, formula: this.formula } } } !function (e) { e.add = "add", e.subtract = "subtract" }(Js || (Js = {})), function (e) { e.seconds = "seconds", e.minutes = "minutes", e.hours = "hours", e.days = "days", e.months = "months", e.years = "years" }(Hs || (Hs = {})); class en extends i { constructor(e, t, r = Hs.seconds, s = Hs.seconds) { super(), this.arguments = e, this.operation = t, this.dateResultUnit = r, this.dateCalculationUnit = s } dateMath(e) { const t = this.operation, r = this; return function (s, n) { if (s instanceof Date && n instanceof Date) return Cr.fromMillis(e(s.getTime(), n.getTime()), { conversionAccuracy: "longterm" }); if (!(s instanceof Date || n instanceof Date)) return Cr.fromMillis(e(s.toMillis(), n.toMillis()), { conversionAccuracy: "longterm" }); let a, o; s instanceof Date && !(n instanceof Date) ? (a = s, o = n) : (a = n, o = s); const i = Es.fromJSDate(a); switch (t) { case Js.add: return i.plus(o).toJSDate(); case Js.subtract: return i.minus(o).toJSDate(); default: throw new Ms("Invalid Operation for Dates", r) } } } evaluate(e) { return n(this, void 0, void 0, function* () { let t; switch (this.operation) { case Js.add: t = (e, t) => e + t; break; case Js.subtract: t = (e, t) => e - t }const r = (yield Promise.all(this.arguments.map(t => n(this, void 0, void 0, function* () { return t instanceof i ? yield t.evaluate(e) : t })))).map(e => (function (e, t) { if (!("number" == typeof e || e instanceof Date)) throw new Fs(t, e) }(e, this), "number" == typeof e ? Cr.fromObject({ [this.dateCalculationUnit]: e }, { conversionAccuracy: "longterm" }) : e)), s = r.splice(1).reduce(this.dateMath((e, r) => Math.round(1e13 * t(e, r)) / 1e13), r[0]); return s instanceof Date ? s : s.as(this.dateResultUnit) }) } toJsonReady() { return { type: "dateCalculation", operation: this.operation, arguments: this.arguments.map(Ks), dateResultUnit: this.dateResultUnit, dateCalculationUnit: this.dateCalculationUnit } } validate() { return this.arguments.length >= 2 && this.arguments.map(e => e instanceof i ? e.validate() : !!e).reduce((e, t) => e && t) } } class tn { fatal(e) { this.error(e) } error(e) { console.error(e) } log(e) { console.log(e) } warn(e) { console.warn(e) } debug(e) { console.log(e) } } let rn = new tn; function sn(e) { rn = e } var nn = r(4541), an = r.n(nn); const on = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json","title":"Main","description":"The entrypoint of the Rita schema","type":"object","properties":{"rules":{"type":"array","title":"Ruleset","description":"Array of all rules in this ruleset.","items":{"$ref":"rule.json"}}},"required":["rules"]}'), cn = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/atom.json","title":"Atom","description":"Describes an atom. Those can be used to read Data","type":"object","properties":{"type":{"type":"string","enum":["atom"]},"path":{"description":"The path to the atom in the data","type":"string"},"isDate":{"type":"boolean","default":false,"description":"Must be set to true if the atom should be parsed as a date"},"default":{"oneOf":[{"type":"string"},{"type":"number"},{"type":"boolean"},{"type":"string","format":"date-time"},{"type":"array"}]}},"required":["type","path"],"additionalProperties":false}'), un = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/operator.json","title":"Operator","oneOf":[{"title":"Non-Unary operator","description":"Requires at least two arguments","type":"object","properties":{"type":{"type":"string","enum":["and","or"]},"arguments":{"type":"array","title":"Multiple arguments","minItems":2,"items":{"$ref":"formula.json"}}},"required":["arguments","type"],"additionalProperties":false},{"title":"Unary operator","description":"Requires exactly on parameter","type":"object","properties":{"type":{"type":"string","enum":["not"]},"arguments":{"type":"array","title":"Unary Arguments","minItems":1,"maxItems":1,"items":{"$ref":"formula.json"}}},"required":["arguments","type"],"additionalProperties":false}]}'), ln = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/rule.json","title":"Rule","type":"object","properties":{"id":{"type":"string"},"comment":{"type":"string","description":"A comment about what the rule does"},"rule":{"$ref":"formula.json"}},"required":["id","rule"],"examples":[{"id":"rule1","rule":{"type":"and","arguments":[{"type":"atom","path":"member"},{"type":"not","arguments":[{"type":"atom","path":"employee"}]}]}}]}'), dn = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/formula.json","title":"Formula","oneOf":[{"$ref":"operator.json"},{"$ref":"atom.json"},{"$ref":"plugin.json"},{"$ref":"comparison.json"},{"$ref":"quantifier.json"}]}'), hn = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/calculation.json","title":"Calculation","description":"Calculates a result","type":"object","properties":{"type":{"type":"string","enum":["calculation"]},"operation":{"description":"The mathematical operation to be calculated. Modulo refers to the function mod(a,b)=a-(floor(a/b)*b)","type":"string","enum":["add","subtract","multiply","divide","modulo"]},"arguments":{"type":"array","minItems":2,"items":{"oneOf":[{"$ref":"atom.json"},{"$ref":"macro.json"},{"type":"number"},{"$ref":"calculation.json"},{"$ref":"dateCalculation.json"}]}}},"required":["operation","arguments","type"],"additionalProperties":false}'), mn = JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/dateCalculation.json","title":"Date Calculation","description":"Calculations involving dates","type":"object","properties":{"type":{"type":"string","enum":["dateCalculation"]},"operation":{"description":"Add/subtract a time interval to/from a date or subtract two dates to get the interval between them","type":"string","enum":["add","subtract"]},"arguments":{"type":"array","minItems":2,"maxItems":2,"items":{"oneOf":[{"$ref":"atom.json"},{"$ref":"macro.json"},{"type":"number"},{"type":"string","format":"date-time"},{"$ref":"calculation.json"},{"$ref":"dateCalculation.json"}]}},"dateCalculationUnit":{"description":"What unit time intervals given as arguments will be in.","type":"string","enum":["seconds","minutes","hours","days","months","years"],"default":"seconds"},"dateResultUnit":{"description":"What unit time intervals representing the result will be in.","type":"string","enum":["seconds","minutes","hours","days","months","years"],"default":"seconds"}},"required":["operation","arguments","type"],"additionalProperties":false}'), fn = [on, cn, ln, dn, un, hn, JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/comparison.json","description":"Compare strings, dates or numbers with each other","title":"Comparison","type":"object","properties":{"type":{"type":"string","enum":["comparison"]},"operation":{"description":"Selects how the arguments should be compared","type":"string","enum":["greater","smaller","greaterOrEqual","smallerOrEqual","equal"]},"dates":{"description":"Indicates if dates are compared","type":"boolean","default":false},"allowDifferentTypes":{"description":"Indicates if different types are allowed inside a comparison. This follows the JavaScript rules for comparison (=== is used for equals).","type":"boolean","default":false},"arguments":{"type":"array","minItems":2,"maxItems":2,"items":{"oneOf":[{"$ref":"atom.json"},{"$ref":"macro.json"},{"type":"number"},{"type":"string","format":"date-time"},{"type":"string"},{"$ref":"calculation.json"},{"$ref":"dateCalculation.json"}]}}},"required":["type","operation","arguments"],"additionalProperties":false,"examples":[{"comment":"This evaluates to \\"5>2\\"","type":"comparison","operation":"greater","arguments":[5,2]},{"comment":"Check two Strings for equality","type":"comparison","operation":"equal","arguments":["test","test1"]}]}'), JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/quantifier.json","title":"Quantifier","type":"object","description":"Quantifiers that can be used to evaluate rules on arrays in Data","properties":{"type":{"type":"string","enum":["forall","exists"]},"array":{"title":"Data array","description":"This can either be an Atom that references an array in the data, or an array of rules","oneOf":[{"type":"array","items":{"$ref":"formula.json"}},{"$ref":"atom.json"}]},"placeholder":{"description":"This is a placeholder name for the current array object. This is the property name with wich you can reference the current value in the subsequent rule","type":"string","minLength":1},"indexPlaceholder":{"description":"This is a placeholder name for the current index of the array object. This is the property name with wich you can reference the current index in the subsequent rule","type":"string","minLength":1,"default":"index"},"rule":{"$ref":"formula.json"}},"additionalProperties":false,"required":["type","array","placeholder","rule"],"examples":[{"type":"forall","array":{"type":"atom","path":"arrayOfIntValues"},"placeholder":"forallItem","rule":{"type":"comparison","operation":"greater","arguments":[5,{"type":"atom","path":"forallItem"}]}}]}'), JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/macro.json","title":"Macro","description":"Describes macros. Available macros are `now` and `length`","type":"object","properties":{"type":{"type":"string","enum":["macro"]},"macro":{"oneOf":[{"title":"now","description":"Returns the current time","type":"object","properties":{"type":{"type":"string","enum":["now"]}},"additionalProperties":false},{"title":"length","description":"Returns the length of an array","type":"object","properties":{"type":{"type":"string","enum":["length"]},"array":{"$ref":"atom.json"}},"additionalProperties":false}]}},"required":["type","macro"],"additionalProperties":false,"examples":[{"type":"macro","macro":{"type":"now"}},{"type":"macro","macro":{"type":"length","array":{"type":"atom","path":"customers"}}}]}'), JSON.parse('{"$schema":"https://json-schema.org/draft/2019-09/schema","$id":"https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/plugin.json","title":"Plugin","description":"Describes an plugin","type":"object","properties":{"type":{"type":"string","enum":["plugin"]},"name":{"description":"The plugins name","type":"string"},"formula":{"$ref":"formula.json"},"options":{"description":"The plugins options","type":"object"}},"required":["type","name","formula"],"additionalProperties":false,"examples":[{"type":"plugin","name":"http","options":{"url":"https://example.com/api"},"formula":{"type":"atom","path":"keyInResponse"}}]}'), mn]; var pn = r(8182), yn = r.n(pn); const gn = new (an())({ schemas: fn }); yn()(gn); class vn { constructor(e) { if (this.plugins = new Map, this.toJson = vn.toJson, this.validate = gn.getSchema("https://raw.githubusercontent.com/educorvi/rita/main/rita-core/src/schema/schema.json"), e) for (const t of e) this.plugins.set(new t({}, void 0).getName(), t) } validateRuleSetJSON(e) { if (!this.validate) throw new Cs("Error compiling schema"); let t = this.validate(e); if ("boolean" != typeof t) throw new Cs("Error compiling schema"); return { valid: t, errors: this.validate.errors || [] } } parseRuleSet(e) { return e.rules.map(e => this.parseRule(e)) } parseRule(e) { return new o(e.id, this.parseFormula(e.rule), e.comment) } parseFormula(e) { switch (e.type) { case "atom": return this.parseAtom(e); case "comparison": return this.parseComparison(e); case "calculation": return this.parseCalculation(e); case "dateCalculation": return this.parseDateCalculation(e); case "forall": case "exists": return this.parseQuantifier(e); case "and": case "or": case "not": return this.parseOperator(e); case "macro": return this.parseMacro(e); case "plugin": return this.parsePlugin(e); default: throw new xs(e.type + " is not implemented") } } parseOperator(e) { const t = e.type, r = []; for (const t of e.arguments) r.push(this.parseFormula(t)); switch (t) { case "not": return new l(r); case "and": return new u(r); case "or": return new d(r) } } parseAtom(e) { return new Us(e.path, !!e.isDate, e.default) } parseComparisonParams(e, t) { const r = []; for (const s of e) if ("object" == typeof s) r.push(this.parseFormula(s)); else if (t) { const e = new Date(s); if (isNaN(e.getTime())) throw new Ts("Invalid Date: " + s); r.push(e) } else r.push(s); return r } parseComparison(e) { return new Ys(this.parseComparisonParams(e.arguments, e.dates), e.operation, e.dates, e.allowDifferentTypes) } parseCalculationParams(e) { const t = []; for (const r of e) "number" == typeof r ? t.push(r) : t.push(this.parseFormula(r)); return t } parseDateCalculationParams(e) { const t = []; for (const r of e) "number" == typeof r ? t.push(r) : "string" == typeof r ? t.push(Ls(r)) : t.push(this.parseFormula(r)); return t } parseCalculation(e) { return new Gs(this.parseCalculationParams(e.arguments), e.operation) } parseDateCalculation(e) { return new en(this.parseDateCalculationParams(e.arguments), e.operation, e.dateResultUnit, e.dateCalculationUnit) } parseQuantifier(e) { let t; return t = Array.isArray(e.array) ? e.array.map(e => this.parseFormula(e)) : this.parseAtom(e.array), new Bs(e.type, t, e.placeholder, e.indexPlaceholder, this.parseFormula(e.rule)) } parseMacro(e) { let t; return "length" === e.macro.type && (t = this.parseAtom(e.macro.array)), new Qs(e.macro.type, t) } parsePlugin(e) { const t = e.name, r = this.plugins.get(t); if (!r) throw new Ts(`Plugin ${t} is not registered!`); return new r(e.options, this.parseFormula(e.formula)) } static toJson(e) { return JSON.stringify({ $schema: on.$id, rules: e.map(e => e.toJsonReady()) }) } } const $n = "5.4.3"; return s
})());