// To parse this JSON data, do
//
//     final jsonSchema = jsonSchemaFromJson(jsonString);
// AUTOGENERATED BY QUICKTYPE.IO - DO NOT MODIFY
// modified manually as some fields are not mandatory. TODO check why the autogenerated file is not correct

import 'dart:convert';

dynamic jsonSchemaFromJson(String str) => json.decode(str);

String jsonSchemaToJson(dynamic data) => json.encode(data);

class JsonSchemaModel {
    String? comment;
    String? id;
    String? ref;
    String? schema;
    dynamic additionalItems;
    dynamic additionalProperties;
    List<dynamic>? allOf;
    List<dynamic>? anyOf;
    dynamic jsonSchemaConst;
    dynamic contains;
    String? contentEncoding;
    String? contentMediaType;
    dynamic jsonSchemaDefault;
    // Map<String, dynamic>? definitions;
    Map<String, dynamic>? dependencies;
    String? description;
    dynamic jsonSchemaElse;
    List<dynamic>? jsonSchemaEnum;
    List<dynamic>? examples;
    double? exclusiveMaximum;
    double? exclusiveMinimum;
    String? format;
    dynamic jsonSchemaIf;
    dynamic items;
    double? maximum;
    int? maxItems;
    int? maxLength;
    int? maxProperties;
    double? minimum;
    int? minItems;
    int? minLength;
    int? minProperties;
    double? multipleOf;
    dynamic not;
    List<dynamic>? oneOf;
    String? pattern;
    Map<String, dynamic>? patternProperties;
    Map<String, dynamic>? properties;
    dynamic propertyNames;
    bool? readOnly;
    List<String>? required;
    dynamic then;
    String? title;
    dynamic type;
    bool? uniqueItems;
    bool? writeOnly;

    JsonSchemaModel({
        this.comment,
        this.id,
        this.ref,
        this.schema,
        this.additionalItems,
        this.additionalProperties,
        this.allOf,
        this.anyOf,
        this.jsonSchemaConst,
        this.contains,
        this.contentEncoding,
        this.contentMediaType,
        this.jsonSchemaDefault,
        // this.definitions,
        this.dependencies,
        this.description,
        this.jsonSchemaElse,
        this.jsonSchemaEnum,
        this.examples,
        this.exclusiveMaximum,
        this.exclusiveMinimum,
        this.format,
        this.jsonSchemaIf,
        this.items,
        this.maximum,
        this.maxItems,
        this.maxLength,
        this.maxProperties,
        this.minimum,
        this.minItems,
        this.minLength,
        this.minProperties,
        this.multipleOf,
        this.not,
        this.oneOf,
        this.pattern,
        this.patternProperties,
        this.properties,
        this.propertyNames,
        this.readOnly,
        this.required,
        this.then,
        this.title,
        this.type,
        this.uniqueItems,
        this.writeOnly,
    });

    factory JsonSchemaModel.fromJson(Map<String, dynamic> json) => JsonSchemaModel(
        comment: json["\u0024comment"],
        id: json["\u0024id"],
        ref: json["\u0024ref"],
        schema: json["\u0024schema"],
        additionalItems: json["additionalItems"],
        additionalProperties: json["additionalProperties"],
        allOf: json["allOf"] == null ? [] : List<dynamic>.from(json["allOf"]!.map((x) => x)),
        anyOf: json["anyOf"] == null ? [] : List<dynamic>.from(json["anyOf"]!.map((x) => x)),
        jsonSchemaConst: json["const"],
        contains: json["contains"],
        contentEncoding: json["contentEncoding"],
        contentMediaType: json["contentMediaType"],
        jsonSchemaDefault: json["default"],
        // definitions: Map.from(json["definitions"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        dependencies: json["dependencies"] == null ? null : Map.from(json["dependencies"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        description: json["description"],
        jsonSchemaElse: json["else"],
        jsonSchemaEnum: json["enum"] == null ? [] : List<dynamic>.from(json["enum"]!.map((x) => x)),
        examples: json["examples"] == null ? [] : List<dynamic>.from(json["examples"]!.map((x) => x)),
        exclusiveMaximum: json["exclusiveMaximum"]?.toDouble(),
        exclusiveMinimum: json["exclusiveMinimum"]?.toDouble(),
        format: json["format"],
        jsonSchemaIf: json["if"],
        items: json["items"],
        maximum: json["maximum"]?.toDouble(),
        maxItems: json["maxItems"],
        maxLength: json["maxLength"],
        maxProperties: json["maxProperties"],
        minimum: json["minimum"]?.toDouble(),
        minItems: json["minItems"],
        minLength: json["minLength"],
        minProperties: json["minProperties"],
        multipleOf: json["multipleOf"]?.toDouble(),
        not: json["not"],
        oneOf: json["oneOf"] == null ? [] : List<dynamic>.from(json["oneOf"]!.map((x) => x)),
        pattern: json["pattern"],
        patternProperties: json["patternProperties"] == null ? null : Map.from(json["patternProperties"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        properties: json["properties"] == null ? null : Map.from(json["properties"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        propertyNames: json["propertyNames"],
        readOnly: json["readOnly"],
        required: json["required"] == null ? [] : List<String>.from(json["required"]!.map((x) => x)),
        then: json["then"],
        title: json["title"],
        type: json["type"],
        uniqueItems: json["uniqueItems"],
        writeOnly: json["writeOnly"],
    );

    Map<String, dynamic> toJson() => {
        "\u0024comment": comment,
        "\u0024id": id,
        "\u0024ref": ref,
        "\u0024schema": schema,
        "additionalItems": additionalItems,
        "additionalProperties": additionalProperties,
        "allOf": allOf == null ? [] : List<dynamic>.from(allOf!.map((x) => x)),
        "anyOf": anyOf == null ? [] : List<dynamic>.from(anyOf!.map((x) => x)),
        "const": jsonSchemaConst,
        "contains": contains,
        "contentEncoding": contentEncoding,
        "contentMediaType": contentMediaType,
        "default": jsonSchemaDefault,
        // "definitions": Map.from(definitions!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "dependencies": dependencies == null ? {} : Map.from(dependencies!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "description": description,
        "else": jsonSchemaElse,
        "enum": jsonSchemaEnum == null ? [] : List<dynamic>.from(jsonSchemaEnum!.map((x) => x)),
        "examples": examples == null ? [] : List<dynamic>.from(examples!.map((x) => x)),
        "exclusiveMaximum": exclusiveMaximum,
        "exclusiveMinimum": exclusiveMinimum,
        "format": format,
        "if": jsonSchemaIf,
        "items": items,
        "maximum": maximum,
        "maxItems": maxItems,
        "maxLength": maxLength,
        "maxProperties": maxProperties,
        "minimum": minimum,
        "minItems": minItems,
        "minLength": minLength,
        "minProperties": minProperties,
        "multipleOf": multipleOf,
        "not": not,
        "oneOf": oneOf == null ? [] : List<dynamic>.from(oneOf!.map((x) => x)),
        "pattern": pattern,
        "patternProperties": patternProperties == null ? {} : Map.from(patternProperties!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "properties": properties == null ? {} : Map.from(properties!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "propertyNames": propertyNames,
        "readOnly": readOnly,
        "required": required == null ? [] : List<dynamic>.from(required!.map((x) => x)),
        "then": then,
        "title": title,
        "type": type,
        "uniqueItems": uniqueItems,
        "writeOnly": writeOnly,
    };
}

class CoreSchemaMetaSchemaClass {
    String? comment;
    String? id;
    String? ref;
    String? schema;
    dynamic additionalItems;
    dynamic additionalProperties;
    List<dynamic>? allOf;
    List<dynamic>? anyOf;
    dynamic coreSchemaMetaSchemaConst;
    dynamic contains;
    String? contentEncoding;
    String? contentMediaType;
    dynamic coreSchemaMetaSchemaDefault;
    Map<String, dynamic>? definitions;
    Map<String, dynamic>? dependencies;
    String? description;
    dynamic coreSchemaMetaSchemaElse;
    List<dynamic>? coreSchemaMetaSchemaEnum;
    List<dynamic>? examples;
    double? exclusiveMaximum;
    double? exclusiveMinimum;
    String? format;
    dynamic coreSchemaMetaSchemaIf;
    dynamic items;
    double? maximum;
    int? maxItems;
    int? maxLength;
    int? maxProperties;
    double? minimum;
    int? minItems;
    int? minLength;
    int? minProperties;
    double? multipleOf;
    dynamic not;
    List<dynamic>? oneOf;
    String? pattern;
    Map<String, dynamic>? patternProperties;
    Map<String, dynamic>? properties;
    dynamic propertyNames;
    bool? readOnly;
    List<String>? required;
    dynamic then;
    String? title;
    dynamic type;
    bool? uniqueItems;
    bool? writeOnly;

    CoreSchemaMetaSchemaClass({
        this.comment,
        this.id,
        this.ref,
        this.schema,
        this.additionalItems,
        this.additionalProperties,
        this.allOf,
        this.anyOf,
        this.coreSchemaMetaSchemaConst,
        this.contains,
        this.contentEncoding,
        this.contentMediaType,
        this.coreSchemaMetaSchemaDefault,
        this.definitions,
        this.dependencies,
        this.description,
        this.coreSchemaMetaSchemaElse,
        this.coreSchemaMetaSchemaEnum,
        this.examples,
        this.exclusiveMaximum,
        this.exclusiveMinimum,
        this.format,
        this.coreSchemaMetaSchemaIf,
        this.items,
        this.maximum,
        this.maxItems,
        this.maxLength,
        this.maxProperties,
        this.minimum,
        this.minItems,
        this.minLength,
        this.minProperties,
        this.multipleOf,
        this.not,
        this.oneOf,
        this.pattern,
        this.patternProperties,
        this.properties,
        this.propertyNames,
        this.readOnly,
        this.required,
        this.then,
        this.title,
        this.type,
        this.uniqueItems,
        this.writeOnly,
    });

    factory CoreSchemaMetaSchemaClass.fromJson(Map<String, dynamic> json) => CoreSchemaMetaSchemaClass(
        comment: json["\u0024comment"],
        id: json["\u0024id"],
        ref: json["\u0024ref"],
        schema: json["\u0024schema"],
        additionalItems: json["additionalItems"],
        additionalProperties: json["additionalProperties"],
        allOf: json["allOf"] == null ? [] : List<dynamic>.from(json["allOf"]!.map((x) => x)),
        anyOf: json["anyOf"] == null ? [] : List<dynamic>.from(json["anyOf"]!.map((x) => x)),
        coreSchemaMetaSchemaConst: json["const"],
        contains: json["contains"],
        contentEncoding: json["contentEncoding"],
        contentMediaType: json["contentMediaType"],
        coreSchemaMetaSchemaDefault: json["default"],
        definitions: Map.from(json["definitions"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        dependencies: Map.from(json["dependencies"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        description: json["description"],
        coreSchemaMetaSchemaElse: json["else"],
        coreSchemaMetaSchemaEnum: json["enum"] == null ? [] : List<dynamic>.from(json["enum"]!.map((x) => x)),
        examples: json["examples"] == null ? [] : List<dynamic>.from(json["examples"]!.map((x) => x)),
        exclusiveMaximum: json["exclusiveMaximum"]?.toDouble(),
        exclusiveMinimum: json["exclusiveMinimum"]?.toDouble(),
        format: json["format"],
        coreSchemaMetaSchemaIf: json["if"],
        items: json["items"],
        maximum: json["maximum"]?.toDouble(),
        maxItems: json["maxItems"],
        maxLength: json["maxLength"],
        maxProperties: json["maxProperties"],
        minimum: json["minimum"]?.toDouble(),
        minItems: json["minItems"],
        minLength: json["minLength"],
        minProperties: json["minProperties"],
        multipleOf: json["multipleOf"]?.toDouble(),
        not: json["not"],
        oneOf: json["oneOf"] == null ? [] : List<dynamic>.from(json["oneOf"]!.map((x) => x)),
        pattern: json["pattern"],
        patternProperties: Map.from(json["patternProperties"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        properties: Map.from(json["properties"]!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        propertyNames: json["propertyNames"],
        readOnly: json["readOnly"],
        required: json["required"] == null ? [] : List<String>.from(json["required"]!.map((x) => x)),
        then: json["then"],
        title: json["title"],
        type: json["type"],
        uniqueItems: json["uniqueItems"],
        writeOnly: json["writeOnly"],
    );

    Map<String, dynamic> toJson() => {
        "\u0024comment": comment,
        "\u0024id": id,
        "\u0024ref": ref,
        "\u0024schema": schema,
        "additionalItems": additionalItems,
        "additionalProperties": additionalProperties,
        "allOf": allOf == null ? [] : List<dynamic>.from(allOf!.map((x) => x)),
        "anyOf": anyOf == null ? [] : List<dynamic>.from(anyOf!.map((x) => x)),
        "const": coreSchemaMetaSchemaConst,
        "contains": contains,
        "contentEncoding": contentEncoding,
        "contentMediaType": contentMediaType,
        "default": coreSchemaMetaSchemaDefault,
        "definitions": Map.from(definitions!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "dependencies": Map.from(dependencies!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "description": description,
        "else": coreSchemaMetaSchemaElse,
        "enum": coreSchemaMetaSchemaEnum == null ? [] : List<dynamic>.from(coreSchemaMetaSchemaEnum!.map((x) => x)),
        "examples": examples == null ? [] : List<dynamic>.from(examples!.map((x) => x)),
        "exclusiveMaximum": exclusiveMaximum,
        "exclusiveMinimum": exclusiveMinimum,
        "format": format,
        "if": coreSchemaMetaSchemaIf,
        "items": items,
        "maximum": maximum,
        "maxItems": maxItems,
        "maxLength": maxLength,
        "maxProperties": maxProperties,
        "minimum": minimum,
        "minItems": minItems,
        "minLength": minLength,
        "minProperties": minProperties,
        "multipleOf": multipleOf,
        "not": not,
        "oneOf": oneOf == null ? [] : List<dynamic>.from(oneOf!.map((x) => x)),
        "pattern": pattern,
        "patternProperties": Map.from(patternProperties!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "properties": Map.from(properties!).map((k, v) => MapEntry<String, dynamic>(k, v)),
        "propertyNames": propertyNames,
        "readOnly": readOnly,
        "required": required == null ? [] : List<dynamic>.from(required!.map((x) => x)),
        "then": then,
        "title": title,
        "type": type,
        "uniqueItems": uniqueItems,
        "writeOnly": writeOnly,
    };
}

enum SimpleTypes {
    ARRAY,
    BOOLEAN,
    INTEGER,
    NULL,
    NUMBER,
    OBJECT,
    STRING
}

final simpleTypesValues = EnumValues({
    "array": SimpleTypes.ARRAY,
    "boolean": SimpleTypes.BOOLEAN,
    "integer": SimpleTypes.INTEGER,
    "null": SimpleTypes.NULL,
    "number": SimpleTypes.NUMBER,
    "object": SimpleTypes.OBJECT,
    "string": SimpleTypes.STRING
});

class EnumValues<T> {
    Map<String, T> map;
    late Map<T, String> reverseMap;

    EnumValues(this.map);

    Map<T, String> get reverse {
        reverseMap = map.map((k, v) => MapEntry(v, k));
        return reverseMap;
    }
}
