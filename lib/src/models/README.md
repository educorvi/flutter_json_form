# Generate Dart Classes:

To generate dart typing classes it would be ideally to directly use `quicktype` on the ui Schema, but this doesn't work as expected. The transcompiler has a problem with dart when `anyOf` and `allOf` are nested within each other. This results in all definitions below this to not be present in the resulting file. But when using the `vue-json-form-schemas.d.ts` file and transcompiling `TypeScript` to `Dart`, all classes were present. The only problem is that the recursive definition of Rita results in the compiler running indefinitely. Since the rita rules are not needed in dart currently as the evaluator is written in typescript, this step is skipped for now.

## Steps to reproduce dart typings:

1. clone [vue-json-forms](https://github.com/educorvi/vue-json-form) repository
2. ~~navigate to `schemas` and run `yarn run install` and `yarn run build` --> in the `dist` folder multiple file should be generated where we will use `vue-json-form-schemas.d.ts`~~
2. run `yarn install` and then `yarn run build:schemas` in the root folder of the repository --> within `packages/schemas/dist` multiple file should be generated where we will use `vue-json-form-schemas.d.ts`
3. rename the file to `vue.json-form-schemas.ts` as quicktype wont generate any classes for `.d.ts` files
4. remove everything concerning `rita` in the file (otherwise quicktype will run indefinitely)
5. install `quicktype` (`v23.2.6` used for reference)
6. run `quicktype vue-json-form-schemas.ts -o UiSchema.dart` (`--debug all` flag can be passed for debugging)
7. an bug exists where an extremely long class `KStringUnknownIdStringUndefinedSchema...` gets generated. To prevent this do:
```typescript
// remove:
export declare type CoreSchemaMetaSchema = CoreSchemaMetaSchema1 & CoreSchemaMetaSchema2;

// remove declaration of class:
export declare type CoreSchemaMetaSchema2 = ...

// and replace all occurences of CoreSchemaMetaSchema2 with | CoreSchemaMetaSchema | boolean (which is essentially the definition of CoreSchemaMetaSchema2)

// rename CoreSchemaMetaSchema1 to CoreSchemaMetaSchema
```

Since union types are not really supported in dart, this leads to `| CoreSchemaMetaSchema | boolean` being simply replaced with `dynamic` so handcrafted class parsers have to be used to check which type the element has.

9. Afterwards the generated file has to be manually adjusted for all occurences of `oneOf` and some `allOf`. The compiler generated merged classes which include all properties of the classes within `oneOf`. See for example `LayoutElement` There handcrafted switch case code is inserted. When the schema changes you can diff/compare the newly generated dart file and manually copy the new fields to the old dart class file.

The autogenerated file is called `uiSchema.d.dart` and is kept for reference. The manually adjusted one is called `uiSchema.dart`